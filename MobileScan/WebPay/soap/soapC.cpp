/* soapC.cpp
   Generated by gSOAP 2.8.4 from webpaysoap.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.4 2017-04-11 07:29:15 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp:
		return soap_in_ns1__SnapQRCodeTakeOrderQueryResp(soap, NULL, NULL, "ns1:SnapQRCodeTakeOrderQueryResp");
	case SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq:
		return soap_in_ns1__SnapQRCodeTakeOrderQueryReq(soap, NULL, NULL, "ns1:SnapQRCodeTakeOrderQueryReq");
	case SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp:
		return soap_in_ns1__SnapQRCodePayResultQueryResp(soap, NULL, NULL, "ns1:SnapQRCodePayResultQueryResp");
	case SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq:
		return soap_in_ns1__SnapQRCodePayResultQueryReq(soap, NULL, NULL, "ns1:SnapQRCodePayResultQueryReq");
	case SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp:
		return soap_in_ns1__SnapQRCodePrePayURLQueryResp(soap, NULL, NULL, "ns1:SnapQRCodePrePayURLQueryResp");
	case SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq:
		return soap_in_ns1__SnapQRCodePrePayURLQueryReq(soap, NULL, NULL, "ns1:SnapQRCodePrePayURLQueryReq");
	case SOAP_TYPE_ns1__HeartBeatResp:
		return soap_in_ns1__HeartBeatResp(soap, NULL, NULL, "ns1:HeartBeatResp");
	case SOAP_TYPE_ns1__HeartBeatReq:
		return soap_in_ns1__HeartBeatReq(soap, NULL, NULL, "ns1:HeartBeatReq");
	case SOAP_TYPE_ns1__OrderExecuteFaultResp:
		return soap_in_ns1__OrderExecuteFaultResp(soap, NULL, NULL, "ns1:OrderExecuteFaultResp");
	case SOAP_TYPE_ns1__OrderExecuteFaultReq:
		return soap_in_ns1__OrderExecuteFaultReq(soap, NULL, NULL, "ns1:OrderExecuteFaultReq");
	case SOAP_TYPE_ns1__OrderExecuteResultResp:
		return soap_in_ns1__OrderExecuteResultResp(soap, NULL, NULL, "ns1:OrderExecuteResultResp");
	case SOAP_TYPE_ns1__OrderExecuteResultReq:
		return soap_in_ns1__OrderExecuteResultReq(soap, NULL, NULL, "ns1:OrderExecuteResultReq");
	case SOAP_TYPE_ns1__Responce:
		return soap_in_ns1__Responce(soap, NULL, NULL, "ns1:Responce");
	case SOAP_TYPE_ns1__OrderCommitResp:
		return soap_in_ns1__OrderCommitResp(soap, NULL, NULL, "ns1:OrderCommitResp");
	case SOAP_TYPE_ns1__ArrayOfString:
		return soap_in_ns1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__Request:
		return soap_in_ns1__Request(soap, NULL, NULL, "ns1:Request");
	case SOAP_TYPE_ns1__OrderCommitReq:
		return soap_in_ns1__OrderCommitReq(soap, NULL, NULL, "ns1:OrderCommitReq");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE020Response:
		return soap_in_PointerTo_ns1__S1_USCORE020Response(soap, NULL, NULL, "ns1:S1_020Response");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE020:
		return soap_in_PointerTo_ns1__S1_USCORE020(soap, NULL, NULL, "ns1:S1_020");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE019Response:
		return soap_in_PointerTo_ns1__S1_USCORE019Response(soap, NULL, NULL, "ns1:S1_019Response");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE019:
		return soap_in_PointerTo_ns1__S1_USCORE019(soap, NULL, NULL, "ns1:S1_019");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE018Response:
		return soap_in_PointerTo_ns1__S1_USCORE018Response(soap, NULL, NULL, "ns1:S1_018Response");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE018:
		return soap_in_PointerTo_ns1__S1_USCORE018(soap, NULL, NULL, "ns1:S1_018");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE009Response:
		return soap_in_PointerTo_ns1__S1_USCORE009Response(soap, NULL, NULL, "ns1:S1_009Response");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE009:
		return soap_in_PointerTo_ns1__S1_USCORE009(soap, NULL, NULL, "ns1:S1_009");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE005Response:
		return soap_in_PointerTo_ns1__S1_USCORE005Response(soap, NULL, NULL, "ns1:S1_005Response");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE005:
		return soap_in_PointerTo_ns1__S1_USCORE005(soap, NULL, NULL, "ns1:S1_005");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE004Response:
		return soap_in_PointerTo_ns1__S1_USCORE004Response(soap, NULL, NULL, "ns1:S1_004Response");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE004:
		return soap_in_PointerTo_ns1__S1_USCORE004(soap, NULL, NULL, "ns1:S1_004");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE001Response:
		return soap_in_PointerTo_ns1__S1_USCORE001Response(soap, NULL, NULL, "ns1:S1_001Response");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE001:
		return soap_in_PointerTo_ns1__S1_USCORE001(soap, NULL, NULL, "ns1:S1_001");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_in_PointerTons1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTons1__SnapQRCodeTakeOrderQueryResp:
		return soap_in_PointerTons1__SnapQRCodeTakeOrderQueryResp(soap, NULL, NULL, "ns1:SnapQRCodeTakeOrderQueryResp");
	case SOAP_TYPE_PointerTons1__SnapQRCodeTakeOrderQueryReq:
		return soap_in_PointerTons1__SnapQRCodeTakeOrderQueryReq(soap, NULL, NULL, "ns1:SnapQRCodeTakeOrderQueryReq");
	case SOAP_TYPE_PointerTons1__SnapQRCodePayResultQueryResp:
		return soap_in_PointerTons1__SnapQRCodePayResultQueryResp(soap, NULL, NULL, "ns1:SnapQRCodePayResultQueryResp");
	case SOAP_TYPE_PointerTons1__SnapQRCodePayResultQueryReq:
		return soap_in_PointerTons1__SnapQRCodePayResultQueryReq(soap, NULL, NULL, "ns1:SnapQRCodePayResultQueryReq");
	case SOAP_TYPE_PointerTons1__SnapQRCodePrePayURLQueryResp:
		return soap_in_PointerTons1__SnapQRCodePrePayURLQueryResp(soap, NULL, NULL, "ns1:SnapQRCodePrePayURLQueryResp");
	case SOAP_TYPE_PointerTons1__SnapQRCodePrePayURLQueryReq:
		return soap_in_PointerTons1__SnapQRCodePrePayURLQueryReq(soap, NULL, NULL, "ns1:SnapQRCodePrePayURLQueryReq");
	case SOAP_TYPE_PointerTons1__HeartBeatResp:
		return soap_in_PointerTons1__HeartBeatResp(soap, NULL, NULL, "ns1:HeartBeatResp");
	case SOAP_TYPE_PointerTons1__HeartBeatReq:
		return soap_in_PointerTons1__HeartBeatReq(soap, NULL, NULL, "ns1:HeartBeatReq");
	case SOAP_TYPE_PointerTons1__OrderExecuteFaultResp:
		return soap_in_PointerTons1__OrderExecuteFaultResp(soap, NULL, NULL, "ns1:OrderExecuteFaultResp");
	case SOAP_TYPE_PointerTons1__OrderExecuteFaultReq:
		return soap_in_PointerTons1__OrderExecuteFaultReq(soap, NULL, NULL, "ns1:OrderExecuteFaultReq");
	case SOAP_TYPE_PointerTons1__OrderExecuteResultResp:
		return soap_in_PointerTons1__OrderExecuteResultResp(soap, NULL, NULL, "ns1:OrderExecuteResultResp");
	case SOAP_TYPE_PointerTons1__OrderExecuteResultReq:
		return soap_in_PointerTons1__OrderExecuteResultReq(soap, NULL, NULL, "ns1:OrderExecuteResultReq");
	case SOAP_TYPE_PointerTons1__OrderCommitResp:
		return soap_in_PointerTons1__OrderCommitResp(soap, NULL, NULL, "ns1:OrderCommitResp");
	case SOAP_TYPE_PointerTons1__OrderCommitReq:
		return soap_in_PointerTons1__OrderCommitReq(soap, NULL, NULL, "ns1:OrderCommitReq");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:SnapQRCodeTakeOrderQueryResp"))
		{	*type = SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp;
			return soap_in_ns1__SnapQRCodeTakeOrderQueryResp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnapQRCodeTakeOrderQueryReq"))
		{	*type = SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq;
			return soap_in_ns1__SnapQRCodeTakeOrderQueryReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnapQRCodePayResultQueryResp"))
		{	*type = SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp;
			return soap_in_ns1__SnapQRCodePayResultQueryResp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnapQRCodePayResultQueryReq"))
		{	*type = SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq;
			return soap_in_ns1__SnapQRCodePayResultQueryReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnapQRCodePrePayURLQueryResp"))
		{	*type = SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp;
			return soap_in_ns1__SnapQRCodePrePayURLQueryResp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnapQRCodePrePayURLQueryReq"))
		{	*type = SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq;
			return soap_in_ns1__SnapQRCodePrePayURLQueryReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HeartBeatResp"))
		{	*type = SOAP_TYPE_ns1__HeartBeatResp;
			return soap_in_ns1__HeartBeatResp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HeartBeatReq"))
		{	*type = SOAP_TYPE_ns1__HeartBeatReq;
			return soap_in_ns1__HeartBeatReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OrderExecuteFaultResp"))
		{	*type = SOAP_TYPE_ns1__OrderExecuteFaultResp;
			return soap_in_ns1__OrderExecuteFaultResp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OrderExecuteFaultReq"))
		{	*type = SOAP_TYPE_ns1__OrderExecuteFaultReq;
			return soap_in_ns1__OrderExecuteFaultReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OrderExecuteResultResp"))
		{	*type = SOAP_TYPE_ns1__OrderExecuteResultResp;
			return soap_in_ns1__OrderExecuteResultResp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OrderExecuteResultReq"))
		{	*type = SOAP_TYPE_ns1__OrderExecuteResultReq;
			return soap_in_ns1__OrderExecuteResultReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Responce"))
		{	*type = SOAP_TYPE_ns1__Responce;
			return soap_in_ns1__Responce(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OrderCommitResp"))
		{	*type = SOAP_TYPE_ns1__OrderCommitResp;
			return soap_in_ns1__OrderCommitResp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfString"))
		{	*type = SOAP_TYPE_ns1__ArrayOfString;
			return soap_in_ns1__ArrayOfString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Request"))
		{	*type = SOAP_TYPE_ns1__Request;
			return soap_in_ns1__Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OrderCommitReq"))
		{	*type = SOAP_TYPE_ns1__OrderCommitReq;
			return soap_in_ns1__OrderCommitReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:S1_020Response"))
		{	*type = SOAP_TYPE__ns1__S1_USCORE020Response;
			return soap_in__ns1__S1_USCORE020Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:S1_020"))
		{	*type = SOAP_TYPE__ns1__S1_USCORE020;
			return soap_in__ns1__S1_USCORE020(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:S1_019Response"))
		{	*type = SOAP_TYPE__ns1__S1_USCORE019Response;
			return soap_in__ns1__S1_USCORE019Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:S1_019"))
		{	*type = SOAP_TYPE__ns1__S1_USCORE019;
			return soap_in__ns1__S1_USCORE019(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:S1_018Response"))
		{	*type = SOAP_TYPE__ns1__S1_USCORE018Response;
			return soap_in__ns1__S1_USCORE018Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:S1_018"))
		{	*type = SOAP_TYPE__ns1__S1_USCORE018;
			return soap_in__ns1__S1_USCORE018(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:S1_009Response"))
		{	*type = SOAP_TYPE__ns1__S1_USCORE009Response;
			return soap_in__ns1__S1_USCORE009Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:S1_009"))
		{	*type = SOAP_TYPE__ns1__S1_USCORE009;
			return soap_in__ns1__S1_USCORE009(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:S1_005Response"))
		{	*type = SOAP_TYPE__ns1__S1_USCORE005Response;
			return soap_in__ns1__S1_USCORE005Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:S1_005"))
		{	*type = SOAP_TYPE__ns1__S1_USCORE005;
			return soap_in__ns1__S1_USCORE005(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:S1_004Response"))
		{	*type = SOAP_TYPE__ns1__S1_USCORE004Response;
			return soap_in__ns1__S1_USCORE004Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:S1_004"))
		{	*type = SOAP_TYPE__ns1__S1_USCORE004;
			return soap_in__ns1__S1_USCORE004(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:S1_001Response"))
		{	*type = SOAP_TYPE__ns1__S1_USCORE001Response;
			return soap_in__ns1__S1_USCORE001Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:S1_001"))
		{	*type = SOAP_TYPE__ns1__S1_USCORE001;
			return soap_in__ns1__S1_USCORE001(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE__ns1__S1_USCORE020Response:
		return ((_ns1__S1_USCORE020Response *)ptr)->soap_out(soap, "ns1:S1_020Response", id, NULL);
	case SOAP_TYPE__ns1__S1_USCORE020:
		return ((_ns1__S1_USCORE020 *)ptr)->soap_out(soap, "ns1:S1_020", id, NULL);
	case SOAP_TYPE__ns1__S1_USCORE019Response:
		return ((_ns1__S1_USCORE019Response *)ptr)->soap_out(soap, "ns1:S1_019Response", id, NULL);
	case SOAP_TYPE__ns1__S1_USCORE019:
		return ((_ns1__S1_USCORE019 *)ptr)->soap_out(soap, "ns1:S1_019", id, NULL);
	case SOAP_TYPE__ns1__S1_USCORE018Response:
		return ((_ns1__S1_USCORE018Response *)ptr)->soap_out(soap, "ns1:S1_018Response", id, NULL);
	case SOAP_TYPE__ns1__S1_USCORE018:
		return ((_ns1__S1_USCORE018 *)ptr)->soap_out(soap, "ns1:S1_018", id, NULL);
	case SOAP_TYPE__ns1__S1_USCORE009Response:
		return ((_ns1__S1_USCORE009Response *)ptr)->soap_out(soap, "ns1:S1_009Response", id, NULL);
	case SOAP_TYPE__ns1__S1_USCORE009:
		return ((_ns1__S1_USCORE009 *)ptr)->soap_out(soap, "ns1:S1_009", id, NULL);
	case SOAP_TYPE__ns1__S1_USCORE005Response:
		return ((_ns1__S1_USCORE005Response *)ptr)->soap_out(soap, "ns1:S1_005Response", id, NULL);
	case SOAP_TYPE__ns1__S1_USCORE005:
		return ((_ns1__S1_USCORE005 *)ptr)->soap_out(soap, "ns1:S1_005", id, NULL);
	case SOAP_TYPE__ns1__S1_USCORE004Response:
		return ((_ns1__S1_USCORE004Response *)ptr)->soap_out(soap, "ns1:S1_004Response", id, NULL);
	case SOAP_TYPE__ns1__S1_USCORE004:
		return ((_ns1__S1_USCORE004 *)ptr)->soap_out(soap, "ns1:S1_004", id, NULL);
	case SOAP_TYPE__ns1__S1_USCORE001Response:
		return ((_ns1__S1_USCORE001Response *)ptr)->soap_out(soap, "ns1:S1_001Response", id, NULL);
	case SOAP_TYPE__ns1__S1_USCORE001:
		return ((_ns1__S1_USCORE001 *)ptr)->soap_out(soap, "ns1:S1_001", id, NULL);
	case SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp:
		return ((ns1__SnapQRCodeTakeOrderQueryResp *)ptr)->soap_out(soap, tag, id, "ns1:SnapQRCodeTakeOrderQueryResp");
	case SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq:
		return ((ns1__SnapQRCodeTakeOrderQueryReq *)ptr)->soap_out(soap, tag, id, "ns1:SnapQRCodeTakeOrderQueryReq");
	case SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp:
		return ((ns1__SnapQRCodePayResultQueryResp *)ptr)->soap_out(soap, tag, id, "ns1:SnapQRCodePayResultQueryResp");
	case SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq:
		return ((ns1__SnapQRCodePayResultQueryReq *)ptr)->soap_out(soap, tag, id, "ns1:SnapQRCodePayResultQueryReq");
	case SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp:
		return ((ns1__SnapQRCodePrePayURLQueryResp *)ptr)->soap_out(soap, tag, id, "ns1:SnapQRCodePrePayURLQueryResp");
	case SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq:
		return ((ns1__SnapQRCodePrePayURLQueryReq *)ptr)->soap_out(soap, tag, id, "ns1:SnapQRCodePrePayURLQueryReq");
	case SOAP_TYPE_ns1__HeartBeatResp:
		return ((ns1__HeartBeatResp *)ptr)->soap_out(soap, tag, id, "ns1:HeartBeatResp");
	case SOAP_TYPE_ns1__HeartBeatReq:
		return ((ns1__HeartBeatReq *)ptr)->soap_out(soap, tag, id, "ns1:HeartBeatReq");
	case SOAP_TYPE_ns1__OrderExecuteFaultResp:
		return ((ns1__OrderExecuteFaultResp *)ptr)->soap_out(soap, tag, id, "ns1:OrderExecuteFaultResp");
	case SOAP_TYPE_ns1__OrderExecuteFaultReq:
		return ((ns1__OrderExecuteFaultReq *)ptr)->soap_out(soap, tag, id, "ns1:OrderExecuteFaultReq");
	case SOAP_TYPE_ns1__OrderExecuteResultResp:
		return ((ns1__OrderExecuteResultResp *)ptr)->soap_out(soap, tag, id, "ns1:OrderExecuteResultResp");
	case SOAP_TYPE_ns1__OrderExecuteResultReq:
		return ((ns1__OrderExecuteResultReq *)ptr)->soap_out(soap, tag, id, "ns1:OrderExecuteResultReq");
	case SOAP_TYPE_ns1__Responce:
		return ((ns1__Responce *)ptr)->soap_out(soap, tag, id, "ns1:Responce");
	case SOAP_TYPE_ns1__OrderCommitResp:
		return ((ns1__OrderCommitResp *)ptr)->soap_out(soap, tag, id, "ns1:OrderCommitResp");
	case SOAP_TYPE_ns1__ArrayOfString:
		return ((ns1__ArrayOfString *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__Request:
		return ((ns1__Request *)ptr)->soap_out(soap, tag, id, "ns1:Request");
	case SOAP_TYPE_ns1__OrderCommitReq:
		return ((ns1__OrderCommitReq *)ptr)->soap_out(soap, tag, id, "ns1:OrderCommitReq");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE020Response:
		return soap_out_PointerTo_ns1__S1_USCORE020Response(soap, tag, id, (_ns1__S1_USCORE020Response *const*)ptr, "ns1:S1_020Response");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE020:
		return soap_out_PointerTo_ns1__S1_USCORE020(soap, tag, id, (_ns1__S1_USCORE020 *const*)ptr, "ns1:S1_020");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE019Response:
		return soap_out_PointerTo_ns1__S1_USCORE019Response(soap, tag, id, (_ns1__S1_USCORE019Response *const*)ptr, "ns1:S1_019Response");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE019:
		return soap_out_PointerTo_ns1__S1_USCORE019(soap, tag, id, (_ns1__S1_USCORE019 *const*)ptr, "ns1:S1_019");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE018Response:
		return soap_out_PointerTo_ns1__S1_USCORE018Response(soap, tag, id, (_ns1__S1_USCORE018Response *const*)ptr, "ns1:S1_018Response");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE018:
		return soap_out_PointerTo_ns1__S1_USCORE018(soap, tag, id, (_ns1__S1_USCORE018 *const*)ptr, "ns1:S1_018");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE009Response:
		return soap_out_PointerTo_ns1__S1_USCORE009Response(soap, tag, id, (_ns1__S1_USCORE009Response *const*)ptr, "ns1:S1_009Response");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE009:
		return soap_out_PointerTo_ns1__S1_USCORE009(soap, tag, id, (_ns1__S1_USCORE009 *const*)ptr, "ns1:S1_009");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE005Response:
		return soap_out_PointerTo_ns1__S1_USCORE005Response(soap, tag, id, (_ns1__S1_USCORE005Response *const*)ptr, "ns1:S1_005Response");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE005:
		return soap_out_PointerTo_ns1__S1_USCORE005(soap, tag, id, (_ns1__S1_USCORE005 *const*)ptr, "ns1:S1_005");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE004Response:
		return soap_out_PointerTo_ns1__S1_USCORE004Response(soap, tag, id, (_ns1__S1_USCORE004Response *const*)ptr, "ns1:S1_004Response");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE004:
		return soap_out_PointerTo_ns1__S1_USCORE004(soap, tag, id, (_ns1__S1_USCORE004 *const*)ptr, "ns1:S1_004");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE001Response:
		return soap_out_PointerTo_ns1__S1_USCORE001Response(soap, tag, id, (_ns1__S1_USCORE001Response *const*)ptr, "ns1:S1_001Response");
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE001:
		return soap_out_PointerTo_ns1__S1_USCORE001(soap, tag, id, (_ns1__S1_USCORE001 *const*)ptr, "ns1:S1_001");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_out_PointerTons1__ArrayOfString(soap, tag, id, (ns1__ArrayOfString *const*)ptr, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTons1__SnapQRCodeTakeOrderQueryResp:
		return soap_out_PointerTons1__SnapQRCodeTakeOrderQueryResp(soap, tag, id, (ns1__SnapQRCodeTakeOrderQueryResp *const*)ptr, "ns1:SnapQRCodeTakeOrderQueryResp");
	case SOAP_TYPE_PointerTons1__SnapQRCodeTakeOrderQueryReq:
		return soap_out_PointerTons1__SnapQRCodeTakeOrderQueryReq(soap, tag, id, (ns1__SnapQRCodeTakeOrderQueryReq *const*)ptr, "ns1:SnapQRCodeTakeOrderQueryReq");
	case SOAP_TYPE_PointerTons1__SnapQRCodePayResultQueryResp:
		return soap_out_PointerTons1__SnapQRCodePayResultQueryResp(soap, tag, id, (ns1__SnapQRCodePayResultQueryResp *const*)ptr, "ns1:SnapQRCodePayResultQueryResp");
	case SOAP_TYPE_PointerTons1__SnapQRCodePayResultQueryReq:
		return soap_out_PointerTons1__SnapQRCodePayResultQueryReq(soap, tag, id, (ns1__SnapQRCodePayResultQueryReq *const*)ptr, "ns1:SnapQRCodePayResultQueryReq");
	case SOAP_TYPE_PointerTons1__SnapQRCodePrePayURLQueryResp:
		return soap_out_PointerTons1__SnapQRCodePrePayURLQueryResp(soap, tag, id, (ns1__SnapQRCodePrePayURLQueryResp *const*)ptr, "ns1:SnapQRCodePrePayURLQueryResp");
	case SOAP_TYPE_PointerTons1__SnapQRCodePrePayURLQueryReq:
		return soap_out_PointerTons1__SnapQRCodePrePayURLQueryReq(soap, tag, id, (ns1__SnapQRCodePrePayURLQueryReq *const*)ptr, "ns1:SnapQRCodePrePayURLQueryReq");
	case SOAP_TYPE_PointerTons1__HeartBeatResp:
		return soap_out_PointerTons1__HeartBeatResp(soap, tag, id, (ns1__HeartBeatResp *const*)ptr, "ns1:HeartBeatResp");
	case SOAP_TYPE_PointerTons1__HeartBeatReq:
		return soap_out_PointerTons1__HeartBeatReq(soap, tag, id, (ns1__HeartBeatReq *const*)ptr, "ns1:HeartBeatReq");
	case SOAP_TYPE_PointerTons1__OrderExecuteFaultResp:
		return soap_out_PointerTons1__OrderExecuteFaultResp(soap, tag, id, (ns1__OrderExecuteFaultResp *const*)ptr, "ns1:OrderExecuteFaultResp");
	case SOAP_TYPE_PointerTons1__OrderExecuteFaultReq:
		return soap_out_PointerTons1__OrderExecuteFaultReq(soap, tag, id, (ns1__OrderExecuteFaultReq *const*)ptr, "ns1:OrderExecuteFaultReq");
	case SOAP_TYPE_PointerTons1__OrderExecuteResultResp:
		return soap_out_PointerTons1__OrderExecuteResultResp(soap, tag, id, (ns1__OrderExecuteResultResp *const*)ptr, "ns1:OrderExecuteResultResp");
	case SOAP_TYPE_PointerTons1__OrderExecuteResultReq:
		return soap_out_PointerTons1__OrderExecuteResultReq(soap, tag, id, (ns1__OrderExecuteResultReq *const*)ptr, "ns1:OrderExecuteResultReq");
	case SOAP_TYPE_PointerTons1__OrderCommitResp:
		return soap_out_PointerTons1__OrderCommitResp(soap, tag, id, (ns1__OrderCommitResp *const*)ptr, "ns1:OrderCommitResp");
	case SOAP_TYPE_PointerTons1__OrderCommitReq:
		return soap_out_PointerTons1__OrderCommitReq(soap, tag, id, (ns1__OrderCommitReq *const*)ptr, "ns1:OrderCommitReq");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__S1_USCORE020Response:
		((_ns1__S1_USCORE020Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__S1_USCORE020:
		((_ns1__S1_USCORE020 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__S1_USCORE019Response:
		((_ns1__S1_USCORE019Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__S1_USCORE019:
		((_ns1__S1_USCORE019 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__S1_USCORE018Response:
		((_ns1__S1_USCORE018Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__S1_USCORE018:
		((_ns1__S1_USCORE018 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__S1_USCORE009Response:
		((_ns1__S1_USCORE009Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__S1_USCORE009:
		((_ns1__S1_USCORE009 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__S1_USCORE005Response:
		((_ns1__S1_USCORE005Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__S1_USCORE005:
		((_ns1__S1_USCORE005 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__S1_USCORE004Response:
		((_ns1__S1_USCORE004Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__S1_USCORE004:
		((_ns1__S1_USCORE004 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__S1_USCORE001Response:
		((_ns1__S1_USCORE001Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__S1_USCORE001:
		((_ns1__S1_USCORE001 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp:
		((ns1__SnapQRCodeTakeOrderQueryResp *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq:
		((ns1__SnapQRCodeTakeOrderQueryReq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp:
		((ns1__SnapQRCodePayResultQueryResp *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq:
		((ns1__SnapQRCodePayResultQueryReq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp:
		((ns1__SnapQRCodePrePayURLQueryResp *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq:
		((ns1__SnapQRCodePrePayURLQueryReq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HeartBeatResp:
		((ns1__HeartBeatResp *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HeartBeatReq:
		((ns1__HeartBeatReq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OrderExecuteFaultResp:
		((ns1__OrderExecuteFaultResp *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OrderExecuteFaultReq:
		((ns1__OrderExecuteFaultReq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OrderExecuteResultResp:
		((ns1__OrderExecuteResultResp *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OrderExecuteResultReq:
		((ns1__OrderExecuteResultReq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Responce:
		((ns1__Responce *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OrderCommitResp:
		((ns1__OrderCommitResp *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		((ns1__ArrayOfString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Request:
		((ns1__Request *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OrderCommitReq:
		((ns1__OrderCommitReq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__S1_USCORE020:
		soap_serialize___ns3__S1_USCORE020(soap, (const struct __ns3__S1_USCORE020 *)ptr);
		break;
	case SOAP_TYPE___ns3__S1_USCORE019:
		soap_serialize___ns3__S1_USCORE019(soap, (const struct __ns3__S1_USCORE019 *)ptr);
		break;
	case SOAP_TYPE___ns3__S1_USCORE018:
		soap_serialize___ns3__S1_USCORE018(soap, (const struct __ns3__S1_USCORE018 *)ptr);
		break;
	case SOAP_TYPE___ns3__S1_USCORE009:
		soap_serialize___ns3__S1_USCORE009(soap, (const struct __ns3__S1_USCORE009 *)ptr);
		break;
	case SOAP_TYPE___ns3__S1_USCORE005:
		soap_serialize___ns3__S1_USCORE005(soap, (const struct __ns3__S1_USCORE005 *)ptr);
		break;
	case SOAP_TYPE___ns3__S1_USCORE004:
		soap_serialize___ns3__S1_USCORE004(soap, (const struct __ns3__S1_USCORE004 *)ptr);
		break;
	case SOAP_TYPE___ns3__S1_USCORE001:
		soap_serialize___ns3__S1_USCORE001(soap, (const struct __ns3__S1_USCORE001 *)ptr);
		break;
	case SOAP_TYPE___ns2__S1_USCORE020:
		soap_serialize___ns2__S1_USCORE020(soap, (const struct __ns2__S1_USCORE020 *)ptr);
		break;
	case SOAP_TYPE___ns2__S1_USCORE019:
		soap_serialize___ns2__S1_USCORE019(soap, (const struct __ns2__S1_USCORE019 *)ptr);
		break;
	case SOAP_TYPE___ns2__S1_USCORE018:
		soap_serialize___ns2__S1_USCORE018(soap, (const struct __ns2__S1_USCORE018 *)ptr);
		break;
	case SOAP_TYPE___ns2__S1_USCORE009:
		soap_serialize___ns2__S1_USCORE009(soap, (const struct __ns2__S1_USCORE009 *)ptr);
		break;
	case SOAP_TYPE___ns2__S1_USCORE005:
		soap_serialize___ns2__S1_USCORE005(soap, (const struct __ns2__S1_USCORE005 *)ptr);
		break;
	case SOAP_TYPE___ns2__S1_USCORE004:
		soap_serialize___ns2__S1_USCORE004(soap, (const struct __ns2__S1_USCORE004 *)ptr);
		break;
	case SOAP_TYPE___ns2__S1_USCORE001:
		soap_serialize___ns2__S1_USCORE001(soap, (const struct __ns2__S1_USCORE001 *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE020Response:
		soap_serialize_PointerTo_ns1__S1_USCORE020Response(soap, (_ns1__S1_USCORE020Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE020:
		soap_serialize_PointerTo_ns1__S1_USCORE020(soap, (_ns1__S1_USCORE020 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE019Response:
		soap_serialize_PointerTo_ns1__S1_USCORE019Response(soap, (_ns1__S1_USCORE019Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE019:
		soap_serialize_PointerTo_ns1__S1_USCORE019(soap, (_ns1__S1_USCORE019 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE018Response:
		soap_serialize_PointerTo_ns1__S1_USCORE018Response(soap, (_ns1__S1_USCORE018Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE018:
		soap_serialize_PointerTo_ns1__S1_USCORE018(soap, (_ns1__S1_USCORE018 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE009Response:
		soap_serialize_PointerTo_ns1__S1_USCORE009Response(soap, (_ns1__S1_USCORE009Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE009:
		soap_serialize_PointerTo_ns1__S1_USCORE009(soap, (_ns1__S1_USCORE009 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE005Response:
		soap_serialize_PointerTo_ns1__S1_USCORE005Response(soap, (_ns1__S1_USCORE005Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE005:
		soap_serialize_PointerTo_ns1__S1_USCORE005(soap, (_ns1__S1_USCORE005 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE004Response:
		soap_serialize_PointerTo_ns1__S1_USCORE004Response(soap, (_ns1__S1_USCORE004Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE004:
		soap_serialize_PointerTo_ns1__S1_USCORE004(soap, (_ns1__S1_USCORE004 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE001Response:
		soap_serialize_PointerTo_ns1__S1_USCORE001Response(soap, (_ns1__S1_USCORE001Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__S1_USCORE001:
		soap_serialize_PointerTo_ns1__S1_USCORE001(soap, (_ns1__S1_USCORE001 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		soap_serialize_PointerTons1__ArrayOfString(soap, (ns1__ArrayOfString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SnapQRCodeTakeOrderQueryResp:
		soap_serialize_PointerTons1__SnapQRCodeTakeOrderQueryResp(soap, (ns1__SnapQRCodeTakeOrderQueryResp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SnapQRCodeTakeOrderQueryReq:
		soap_serialize_PointerTons1__SnapQRCodeTakeOrderQueryReq(soap, (ns1__SnapQRCodeTakeOrderQueryReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SnapQRCodePayResultQueryResp:
		soap_serialize_PointerTons1__SnapQRCodePayResultQueryResp(soap, (ns1__SnapQRCodePayResultQueryResp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SnapQRCodePayResultQueryReq:
		soap_serialize_PointerTons1__SnapQRCodePayResultQueryReq(soap, (ns1__SnapQRCodePayResultQueryReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SnapQRCodePrePayURLQueryResp:
		soap_serialize_PointerTons1__SnapQRCodePrePayURLQueryResp(soap, (ns1__SnapQRCodePrePayURLQueryResp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SnapQRCodePrePayURLQueryReq:
		soap_serialize_PointerTons1__SnapQRCodePrePayURLQueryReq(soap, (ns1__SnapQRCodePrePayURLQueryReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HeartBeatResp:
		soap_serialize_PointerTons1__HeartBeatResp(soap, (ns1__HeartBeatResp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HeartBeatReq:
		soap_serialize_PointerTons1__HeartBeatReq(soap, (ns1__HeartBeatReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OrderExecuteFaultResp:
		soap_serialize_PointerTons1__OrderExecuteFaultResp(soap, (ns1__OrderExecuteFaultResp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OrderExecuteFaultReq:
		soap_serialize_PointerTons1__OrderExecuteFaultReq(soap, (ns1__OrderExecuteFaultReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OrderExecuteResultResp:
		soap_serialize_PointerTons1__OrderExecuteResultResp(soap, (ns1__OrderExecuteResultResp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OrderExecuteResultReq:
		soap_serialize_PointerTons1__OrderExecuteResultReq(soap, (ns1__OrderExecuteResultReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OrderCommitResp:
		soap_serialize_PointerTons1__OrderCommitResp(soap, (ns1__OrderCommitResp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OrderCommitReq:
		soap_serialize_PointerTons1__OrderCommitReq(soap, (ns1__OrderCommitReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_ns1__Request:
		return (void*)soap_instantiate_ns1__Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfString:
		return (void*)soap_instantiate_ns1__ArrayOfString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Responce:
		return (void*)soap_instantiate_ns1__Responce(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__S1_USCORE001:
		return (void*)soap_instantiate__ns1__S1_USCORE001(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__S1_USCORE001Response:
		return (void*)soap_instantiate__ns1__S1_USCORE001Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__S1_USCORE004:
		return (void*)soap_instantiate__ns1__S1_USCORE004(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__S1_USCORE004Response:
		return (void*)soap_instantiate__ns1__S1_USCORE004Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__S1_USCORE005:
		return (void*)soap_instantiate__ns1__S1_USCORE005(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__S1_USCORE005Response:
		return (void*)soap_instantiate__ns1__S1_USCORE005Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__S1_USCORE009:
		return (void*)soap_instantiate__ns1__S1_USCORE009(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__S1_USCORE009Response:
		return (void*)soap_instantiate__ns1__S1_USCORE009Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__S1_USCORE018:
		return (void*)soap_instantiate__ns1__S1_USCORE018(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__S1_USCORE018Response:
		return (void*)soap_instantiate__ns1__S1_USCORE018Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__S1_USCORE019:
		return (void*)soap_instantiate__ns1__S1_USCORE019(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__S1_USCORE019Response:
		return (void*)soap_instantiate__ns1__S1_USCORE019Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__S1_USCORE020:
		return (void*)soap_instantiate__ns1__S1_USCORE020(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__S1_USCORE020Response:
		return (void*)soap_instantiate__ns1__S1_USCORE020Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OrderCommitReq:
		return (void*)soap_instantiate_ns1__OrderCommitReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OrderCommitResp:
		return (void*)soap_instantiate_ns1__OrderCommitResp(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OrderExecuteResultReq:
		return (void*)soap_instantiate_ns1__OrderExecuteResultReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OrderExecuteResultResp:
		return (void*)soap_instantiate_ns1__OrderExecuteResultResp(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OrderExecuteFaultReq:
		return (void*)soap_instantiate_ns1__OrderExecuteFaultReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OrderExecuteFaultResp:
		return (void*)soap_instantiate_ns1__OrderExecuteFaultResp(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HeartBeatReq:
		return (void*)soap_instantiate_ns1__HeartBeatReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HeartBeatResp:
		return (void*)soap_instantiate_ns1__HeartBeatResp(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq:
		return (void*)soap_instantiate_ns1__SnapQRCodePrePayURLQueryReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp:
		return (void*)soap_instantiate_ns1__SnapQRCodePrePayURLQueryResp(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq:
		return (void*)soap_instantiate_ns1__SnapQRCodePayResultQueryReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp:
		return (void*)soap_instantiate_ns1__SnapQRCodePayResultQueryResp(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq:
		return (void*)soap_instantiate_ns1__SnapQRCodeTakeOrderQueryReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp:
		return (void*)soap_instantiate_ns1__SnapQRCodeTakeOrderQueryResp(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__S1_USCORE001:
		return (void*)soap_instantiate___ns2__S1_USCORE001(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__S1_USCORE004:
		return (void*)soap_instantiate___ns2__S1_USCORE004(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__S1_USCORE005:
		return (void*)soap_instantiate___ns2__S1_USCORE005(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__S1_USCORE009:
		return (void*)soap_instantiate___ns2__S1_USCORE009(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__S1_USCORE018:
		return (void*)soap_instantiate___ns2__S1_USCORE018(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__S1_USCORE019:
		return (void*)soap_instantiate___ns2__S1_USCORE019(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__S1_USCORE020:
		return (void*)soap_instantiate___ns2__S1_USCORE020(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__S1_USCORE001:
		return (void*)soap_instantiate___ns3__S1_USCORE001(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__S1_USCORE004:
		return (void*)soap_instantiate___ns3__S1_USCORE004(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__S1_USCORE005:
		return (void*)soap_instantiate___ns3__S1_USCORE005(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__S1_USCORE009:
		return (void*)soap_instantiate___ns3__S1_USCORE009(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__S1_USCORE018:
		return (void*)soap_instantiate___ns3__S1_USCORE018(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__S1_USCORE019:
		return (void*)soap_instantiate___ns3__S1_USCORE019(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__S1_USCORE020:
		return (void*)soap_instantiate___ns3__S1_USCORE020(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns1__Request:
		if (p->size < 0)
			SOAP_DELETE((ns1__Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Request*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfString*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfString*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Responce:
		if (p->size < 0)
			SOAP_DELETE((ns1__Responce*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Responce*)p->ptr);
		break;
	case SOAP_TYPE__ns1__S1_USCORE001:
		if (p->size < 0)
			SOAP_DELETE((_ns1__S1_USCORE001*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__S1_USCORE001*)p->ptr);
		break;
	case SOAP_TYPE__ns1__S1_USCORE001Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1__S1_USCORE001Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__S1_USCORE001Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1__S1_USCORE004:
		if (p->size < 0)
			SOAP_DELETE((_ns1__S1_USCORE004*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__S1_USCORE004*)p->ptr);
		break;
	case SOAP_TYPE__ns1__S1_USCORE004Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1__S1_USCORE004Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__S1_USCORE004Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1__S1_USCORE005:
		if (p->size < 0)
			SOAP_DELETE((_ns1__S1_USCORE005*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__S1_USCORE005*)p->ptr);
		break;
	case SOAP_TYPE__ns1__S1_USCORE005Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1__S1_USCORE005Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__S1_USCORE005Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1__S1_USCORE009:
		if (p->size < 0)
			SOAP_DELETE((_ns1__S1_USCORE009*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__S1_USCORE009*)p->ptr);
		break;
	case SOAP_TYPE__ns1__S1_USCORE009Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1__S1_USCORE009Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__S1_USCORE009Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1__S1_USCORE018:
		if (p->size < 0)
			SOAP_DELETE((_ns1__S1_USCORE018*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__S1_USCORE018*)p->ptr);
		break;
	case SOAP_TYPE__ns1__S1_USCORE018Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1__S1_USCORE018Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__S1_USCORE018Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1__S1_USCORE019:
		if (p->size < 0)
			SOAP_DELETE((_ns1__S1_USCORE019*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__S1_USCORE019*)p->ptr);
		break;
	case SOAP_TYPE__ns1__S1_USCORE019Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1__S1_USCORE019Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__S1_USCORE019Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1__S1_USCORE020:
		if (p->size < 0)
			SOAP_DELETE((_ns1__S1_USCORE020*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__S1_USCORE020*)p->ptr);
		break;
	case SOAP_TYPE__ns1__S1_USCORE020Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1__S1_USCORE020Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__S1_USCORE020Response*)p->ptr);
		break;
	case SOAP_TYPE_ns1__OrderCommitReq:
		if (p->size < 0)
			SOAP_DELETE((ns1__OrderCommitReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__OrderCommitReq*)p->ptr);
		break;
	case SOAP_TYPE_ns1__OrderCommitResp:
		if (p->size < 0)
			SOAP_DELETE((ns1__OrderCommitResp*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__OrderCommitResp*)p->ptr);
		break;
	case SOAP_TYPE_ns1__OrderExecuteResultReq:
		if (p->size < 0)
			SOAP_DELETE((ns1__OrderExecuteResultReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__OrderExecuteResultReq*)p->ptr);
		break;
	case SOAP_TYPE_ns1__OrderExecuteResultResp:
		if (p->size < 0)
			SOAP_DELETE((ns1__OrderExecuteResultResp*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__OrderExecuteResultResp*)p->ptr);
		break;
	case SOAP_TYPE_ns1__OrderExecuteFaultReq:
		if (p->size < 0)
			SOAP_DELETE((ns1__OrderExecuteFaultReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__OrderExecuteFaultReq*)p->ptr);
		break;
	case SOAP_TYPE_ns1__OrderExecuteFaultResp:
		if (p->size < 0)
			SOAP_DELETE((ns1__OrderExecuteFaultResp*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__OrderExecuteFaultResp*)p->ptr);
		break;
	case SOAP_TYPE_ns1__HeartBeatReq:
		if (p->size < 0)
			SOAP_DELETE((ns1__HeartBeatReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__HeartBeatReq*)p->ptr);
		break;
	case SOAP_TYPE_ns1__HeartBeatResp:
		if (p->size < 0)
			SOAP_DELETE((ns1__HeartBeatResp*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__HeartBeatResp*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq:
		if (p->size < 0)
			SOAP_DELETE((ns1__SnapQRCodePrePayURLQueryReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SnapQRCodePrePayURLQueryReq*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp:
		if (p->size < 0)
			SOAP_DELETE((ns1__SnapQRCodePrePayURLQueryResp*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SnapQRCodePrePayURLQueryResp*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq:
		if (p->size < 0)
			SOAP_DELETE((ns1__SnapQRCodePayResultQueryReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SnapQRCodePayResultQueryReq*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp:
		if (p->size < 0)
			SOAP_DELETE((ns1__SnapQRCodePayResultQueryResp*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SnapQRCodePayResultQueryResp*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq:
		if (p->size < 0)
			SOAP_DELETE((ns1__SnapQRCodeTakeOrderQueryReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SnapQRCodeTakeOrderQueryReq*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp:
		if (p->size < 0)
			SOAP_DELETE((ns1__SnapQRCodeTakeOrderQueryResp*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SnapQRCodeTakeOrderQueryResp*)p->ptr);
		break;
	case SOAP_TYPE___ns2__S1_USCORE001:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__S1_USCORE001*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__S1_USCORE001*)p->ptr);
		break;
	case SOAP_TYPE___ns2__S1_USCORE004:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__S1_USCORE004*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__S1_USCORE004*)p->ptr);
		break;
	case SOAP_TYPE___ns2__S1_USCORE005:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__S1_USCORE005*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__S1_USCORE005*)p->ptr);
		break;
	case SOAP_TYPE___ns2__S1_USCORE009:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__S1_USCORE009*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__S1_USCORE009*)p->ptr);
		break;
	case SOAP_TYPE___ns2__S1_USCORE018:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__S1_USCORE018*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__S1_USCORE018*)p->ptr);
		break;
	case SOAP_TYPE___ns2__S1_USCORE019:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__S1_USCORE019*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__S1_USCORE019*)p->ptr);
		break;
	case SOAP_TYPE___ns2__S1_USCORE020:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__S1_USCORE020*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__S1_USCORE020*)p->ptr);
		break;
	case SOAP_TYPE___ns3__S1_USCORE001:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__S1_USCORE001*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__S1_USCORE001*)p->ptr);
		break;
	case SOAP_TYPE___ns3__S1_USCORE004:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__S1_USCORE004*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__S1_USCORE004*)p->ptr);
		break;
	case SOAP_TYPE___ns3__S1_USCORE005:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__S1_USCORE005*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__S1_USCORE005*)p->ptr);
		break;
	case SOAP_TYPE___ns3__S1_USCORE009:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__S1_USCORE009*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__S1_USCORE009*)p->ptr);
		break;
	case SOAP_TYPE___ns3__S1_USCORE018:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__S1_USCORE018*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__S1_USCORE018*)p->ptr);
		break;
	case SOAP_TYPE___ns3__S1_USCORE019:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__S1_USCORE019*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__S1_USCORE019*)p->ptr);
		break;
	case SOAP_TYPE___ns3__S1_USCORE020:
		if (p->size < 0)
			SOAP_DELETE((struct __ns3__S1_USCORE020*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns3__S1_USCORE020*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__S1_USCORE020Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__S1_USCORE020Response::S1_USCORE020Result = NULL;
	/* transient soap skipped */
}

void _ns1__S1_USCORE020Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SnapQRCodeTakeOrderQueryResp(soap, &this->_ns1__S1_USCORE020Response::S1_USCORE020Result);
	/* transient soap skipped */
}

int _ns1__S1_USCORE020Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__S1_USCORE020Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__S1_USCORE020Response(struct soap *soap, const char *tag, int id, const _ns1__S1_USCORE020Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__S1_USCORE020Response), type))
		return soap->error;
	if (a->S1_USCORE020Result)
		soap_element_result(soap, "ns1:S1_020Result");
	if (soap_out_PointerTons1__SnapQRCodeTakeOrderQueryResp(soap, "ns1:S1_020Result", -1, &(a->_ns1__S1_USCORE020Response::S1_USCORE020Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__S1_USCORE020Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__S1_USCORE020Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__S1_USCORE020Response * SOAP_FMAC4 soap_in__ns1__S1_USCORE020Response(struct soap *soap, const char *tag, _ns1__S1_USCORE020Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__S1_USCORE020Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__S1_USCORE020Response, sizeof(_ns1__S1_USCORE020Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__S1_USCORE020Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__S1_USCORE020Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_S1_USCORE020Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_S1_USCORE020Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SnapQRCodeTakeOrderQueryResp(soap, "ns1:S1_020Result", &(a->_ns1__S1_USCORE020Response::S1_USCORE020Result), "ns1:SnapQRCodeTakeOrderQueryResp"))
				{	soap_flag_S1_USCORE020Result1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:S1_020Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__S1_USCORE020Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__S1_USCORE020Response, 0, sizeof(_ns1__S1_USCORE020Response), 0, soap_copy__ns1__S1_USCORE020Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__S1_USCORE020Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__S1_USCORE020Response);
	if (this->soap_out(soap, tag?tag:"ns1:S1_020Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__S1_USCORE020Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__S1_USCORE020Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__S1_USCORE020Response * SOAP_FMAC4 soap_get__ns1__S1_USCORE020Response(struct soap *soap, _ns1__S1_USCORE020Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__S1_USCORE020Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__S1_USCORE020Response * SOAP_FMAC2 soap_instantiate__ns1__S1_USCORE020Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__S1_USCORE020Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__S1_USCORE020Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE020Response);
		if (size)
			*size = sizeof(_ns1__S1_USCORE020Response);
		((_ns1__S1_USCORE020Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE020Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__S1_USCORE020Response);
		for (int i = 0; i < n; i++)
			((_ns1__S1_USCORE020Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__S1_USCORE020Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__S1_USCORE020Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__S1_USCORE020Response %p -> %p\n", q, p));
	*(_ns1__S1_USCORE020Response*)p = *(_ns1__S1_USCORE020Response*)q;
}

void _ns1__S1_USCORE020::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__S1_USCORE020::snapQRCodeTakeOrderQueryReq = NULL;
	/* transient soap skipped */
}

void _ns1__S1_USCORE020::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SnapQRCodeTakeOrderQueryReq(soap, &this->_ns1__S1_USCORE020::snapQRCodeTakeOrderQueryReq);
	/* transient soap skipped */
}

int _ns1__S1_USCORE020::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__S1_USCORE020(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__S1_USCORE020(struct soap *soap, const char *tag, int id, const _ns1__S1_USCORE020 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__S1_USCORE020), type))
		return soap->error;
	if (soap_out_PointerTons1__SnapQRCodeTakeOrderQueryReq(soap, "ns1:snapQRCodeTakeOrderQueryReq", -1, &(a->_ns1__S1_USCORE020::snapQRCodeTakeOrderQueryReq), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__S1_USCORE020::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__S1_USCORE020(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__S1_USCORE020 * SOAP_FMAC4 soap_in__ns1__S1_USCORE020(struct soap *soap, const char *tag, _ns1__S1_USCORE020 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__S1_USCORE020 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__S1_USCORE020, sizeof(_ns1__S1_USCORE020), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__S1_USCORE020)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__S1_USCORE020 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_snapQRCodeTakeOrderQueryReq1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_snapQRCodeTakeOrderQueryReq1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SnapQRCodeTakeOrderQueryReq(soap, "ns1:snapQRCodeTakeOrderQueryReq", &(a->_ns1__S1_USCORE020::snapQRCodeTakeOrderQueryReq), "ns1:SnapQRCodeTakeOrderQueryReq"))
				{	soap_flag_snapQRCodeTakeOrderQueryReq1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__S1_USCORE020 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__S1_USCORE020, 0, sizeof(_ns1__S1_USCORE020), 0, soap_copy__ns1__S1_USCORE020);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__S1_USCORE020::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__S1_USCORE020);
	if (this->soap_out(soap, tag?tag:"ns1:S1_020", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__S1_USCORE020::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__S1_USCORE020(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__S1_USCORE020 * SOAP_FMAC4 soap_get__ns1__S1_USCORE020(struct soap *soap, _ns1__S1_USCORE020 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__S1_USCORE020(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__S1_USCORE020 * SOAP_FMAC2 soap_instantiate__ns1__S1_USCORE020(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__S1_USCORE020(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__S1_USCORE020, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE020);
		if (size)
			*size = sizeof(_ns1__S1_USCORE020);
		((_ns1__S1_USCORE020*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE020[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__S1_USCORE020);
		for (int i = 0; i < n; i++)
			((_ns1__S1_USCORE020*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__S1_USCORE020*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__S1_USCORE020(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__S1_USCORE020 %p -> %p\n", q, p));
	*(_ns1__S1_USCORE020*)p = *(_ns1__S1_USCORE020*)q;
}

void _ns1__S1_USCORE019Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__S1_USCORE019Response::S1_USCORE019Result = NULL;
	/* transient soap skipped */
}

void _ns1__S1_USCORE019Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SnapQRCodePayResultQueryResp(soap, &this->_ns1__S1_USCORE019Response::S1_USCORE019Result);
	/* transient soap skipped */
}

int _ns1__S1_USCORE019Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__S1_USCORE019Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__S1_USCORE019Response(struct soap *soap, const char *tag, int id, const _ns1__S1_USCORE019Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__S1_USCORE019Response), type))
		return soap->error;
	if (a->S1_USCORE019Result)
		soap_element_result(soap, "ns1:S1_019Result");
	if (soap_out_PointerTons1__SnapQRCodePayResultQueryResp(soap, "ns1:S1_019Result", -1, &(a->_ns1__S1_USCORE019Response::S1_USCORE019Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__S1_USCORE019Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__S1_USCORE019Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__S1_USCORE019Response * SOAP_FMAC4 soap_in__ns1__S1_USCORE019Response(struct soap *soap, const char *tag, _ns1__S1_USCORE019Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__S1_USCORE019Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__S1_USCORE019Response, sizeof(_ns1__S1_USCORE019Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__S1_USCORE019Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__S1_USCORE019Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_S1_USCORE019Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_S1_USCORE019Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SnapQRCodePayResultQueryResp(soap, "ns1:S1_019Result", &(a->_ns1__S1_USCORE019Response::S1_USCORE019Result), "ns1:SnapQRCodePayResultQueryResp"))
				{	soap_flag_S1_USCORE019Result1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:S1_019Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__S1_USCORE019Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__S1_USCORE019Response, 0, sizeof(_ns1__S1_USCORE019Response), 0, soap_copy__ns1__S1_USCORE019Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__S1_USCORE019Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__S1_USCORE019Response);
	if (this->soap_out(soap, tag?tag:"ns1:S1_019Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__S1_USCORE019Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__S1_USCORE019Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__S1_USCORE019Response * SOAP_FMAC4 soap_get__ns1__S1_USCORE019Response(struct soap *soap, _ns1__S1_USCORE019Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__S1_USCORE019Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__S1_USCORE019Response * SOAP_FMAC2 soap_instantiate__ns1__S1_USCORE019Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__S1_USCORE019Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__S1_USCORE019Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE019Response);
		if (size)
			*size = sizeof(_ns1__S1_USCORE019Response);
		((_ns1__S1_USCORE019Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE019Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__S1_USCORE019Response);
		for (int i = 0; i < n; i++)
			((_ns1__S1_USCORE019Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__S1_USCORE019Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__S1_USCORE019Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__S1_USCORE019Response %p -> %p\n", q, p));
	*(_ns1__S1_USCORE019Response*)p = *(_ns1__S1_USCORE019Response*)q;
}

void _ns1__S1_USCORE019::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__S1_USCORE019::snapQRCodePayResultQueryReq = NULL;
	/* transient soap skipped */
}

void _ns1__S1_USCORE019::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SnapQRCodePayResultQueryReq(soap, &this->_ns1__S1_USCORE019::snapQRCodePayResultQueryReq);
	/* transient soap skipped */
}

int _ns1__S1_USCORE019::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__S1_USCORE019(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__S1_USCORE019(struct soap *soap, const char *tag, int id, const _ns1__S1_USCORE019 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__S1_USCORE019), type))
		return soap->error;
	if (soap_out_PointerTons1__SnapQRCodePayResultQueryReq(soap, "ns1:snapQRCodePayResultQueryReq", -1, &(a->_ns1__S1_USCORE019::snapQRCodePayResultQueryReq), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__S1_USCORE019::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__S1_USCORE019(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__S1_USCORE019 * SOAP_FMAC4 soap_in__ns1__S1_USCORE019(struct soap *soap, const char *tag, _ns1__S1_USCORE019 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__S1_USCORE019 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__S1_USCORE019, sizeof(_ns1__S1_USCORE019), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__S1_USCORE019)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__S1_USCORE019 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_snapQRCodePayResultQueryReq1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_snapQRCodePayResultQueryReq1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SnapQRCodePayResultQueryReq(soap, "ns1:snapQRCodePayResultQueryReq", &(a->_ns1__S1_USCORE019::snapQRCodePayResultQueryReq), "ns1:SnapQRCodePayResultQueryReq"))
				{	soap_flag_snapQRCodePayResultQueryReq1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__S1_USCORE019 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__S1_USCORE019, 0, sizeof(_ns1__S1_USCORE019), 0, soap_copy__ns1__S1_USCORE019);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__S1_USCORE019::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__S1_USCORE019);
	if (this->soap_out(soap, tag?tag:"ns1:S1_019", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__S1_USCORE019::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__S1_USCORE019(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__S1_USCORE019 * SOAP_FMAC4 soap_get__ns1__S1_USCORE019(struct soap *soap, _ns1__S1_USCORE019 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__S1_USCORE019(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__S1_USCORE019 * SOAP_FMAC2 soap_instantiate__ns1__S1_USCORE019(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__S1_USCORE019(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__S1_USCORE019, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE019);
		if (size)
			*size = sizeof(_ns1__S1_USCORE019);
		((_ns1__S1_USCORE019*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE019[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__S1_USCORE019);
		for (int i = 0; i < n; i++)
			((_ns1__S1_USCORE019*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__S1_USCORE019*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__S1_USCORE019(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__S1_USCORE019 %p -> %p\n", q, p));
	*(_ns1__S1_USCORE019*)p = *(_ns1__S1_USCORE019*)q;
}

void _ns1__S1_USCORE018Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__S1_USCORE018Response::S1_USCORE018Result = NULL;
	/* transient soap skipped */
}

void _ns1__S1_USCORE018Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SnapQRCodePrePayURLQueryResp(soap, &this->_ns1__S1_USCORE018Response::S1_USCORE018Result);
	/* transient soap skipped */
}

int _ns1__S1_USCORE018Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__S1_USCORE018Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__S1_USCORE018Response(struct soap *soap, const char *tag, int id, const _ns1__S1_USCORE018Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__S1_USCORE018Response), type))
		return soap->error;
	if (a->S1_USCORE018Result)
		soap_element_result(soap, "ns1:S1_018Result");
	if (soap_out_PointerTons1__SnapQRCodePrePayURLQueryResp(soap, "ns1:S1_018Result", -1, &(a->_ns1__S1_USCORE018Response::S1_USCORE018Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__S1_USCORE018Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__S1_USCORE018Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__S1_USCORE018Response * SOAP_FMAC4 soap_in__ns1__S1_USCORE018Response(struct soap *soap, const char *tag, _ns1__S1_USCORE018Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__S1_USCORE018Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__S1_USCORE018Response, sizeof(_ns1__S1_USCORE018Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__S1_USCORE018Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__S1_USCORE018Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_S1_USCORE018Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_S1_USCORE018Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SnapQRCodePrePayURLQueryResp(soap, "ns1:S1_018Result", &(a->_ns1__S1_USCORE018Response::S1_USCORE018Result), "ns1:SnapQRCodePrePayURLQueryResp"))
				{	soap_flag_S1_USCORE018Result1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:S1_018Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__S1_USCORE018Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__S1_USCORE018Response, 0, sizeof(_ns1__S1_USCORE018Response), 0, soap_copy__ns1__S1_USCORE018Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__S1_USCORE018Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__S1_USCORE018Response);
	if (this->soap_out(soap, tag?tag:"ns1:S1_018Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__S1_USCORE018Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__S1_USCORE018Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__S1_USCORE018Response * SOAP_FMAC4 soap_get__ns1__S1_USCORE018Response(struct soap *soap, _ns1__S1_USCORE018Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__S1_USCORE018Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__S1_USCORE018Response * SOAP_FMAC2 soap_instantiate__ns1__S1_USCORE018Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__S1_USCORE018Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__S1_USCORE018Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE018Response);
		if (size)
			*size = sizeof(_ns1__S1_USCORE018Response);
		((_ns1__S1_USCORE018Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE018Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__S1_USCORE018Response);
		for (int i = 0; i < n; i++)
			((_ns1__S1_USCORE018Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__S1_USCORE018Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__S1_USCORE018Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__S1_USCORE018Response %p -> %p\n", q, p));
	*(_ns1__S1_USCORE018Response*)p = *(_ns1__S1_USCORE018Response*)q;
}

void _ns1__S1_USCORE018::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__S1_USCORE018::snapQRCodePrePayURLQueryReq = NULL;
	/* transient soap skipped */
}

void _ns1__S1_USCORE018::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SnapQRCodePrePayURLQueryReq(soap, &this->_ns1__S1_USCORE018::snapQRCodePrePayURLQueryReq);
	/* transient soap skipped */
}

int _ns1__S1_USCORE018::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__S1_USCORE018(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__S1_USCORE018(struct soap *soap, const char *tag, int id, const _ns1__S1_USCORE018 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__S1_USCORE018), type))
		return soap->error;
	if (soap_out_PointerTons1__SnapQRCodePrePayURLQueryReq(soap, "ns1:snapQRCodePrePayURLQueryReq", -1, &(a->_ns1__S1_USCORE018::snapQRCodePrePayURLQueryReq), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__S1_USCORE018::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__S1_USCORE018(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__S1_USCORE018 * SOAP_FMAC4 soap_in__ns1__S1_USCORE018(struct soap *soap, const char *tag, _ns1__S1_USCORE018 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__S1_USCORE018 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__S1_USCORE018, sizeof(_ns1__S1_USCORE018), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__S1_USCORE018)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__S1_USCORE018 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_snapQRCodePrePayURLQueryReq1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_snapQRCodePrePayURLQueryReq1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SnapQRCodePrePayURLQueryReq(soap, "ns1:snapQRCodePrePayURLQueryReq", &(a->_ns1__S1_USCORE018::snapQRCodePrePayURLQueryReq), "ns1:SnapQRCodePrePayURLQueryReq"))
				{	soap_flag_snapQRCodePrePayURLQueryReq1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__S1_USCORE018 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__S1_USCORE018, 0, sizeof(_ns1__S1_USCORE018), 0, soap_copy__ns1__S1_USCORE018);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__S1_USCORE018::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__S1_USCORE018);
	if (this->soap_out(soap, tag?tag:"ns1:S1_018", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__S1_USCORE018::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__S1_USCORE018(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__S1_USCORE018 * SOAP_FMAC4 soap_get__ns1__S1_USCORE018(struct soap *soap, _ns1__S1_USCORE018 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__S1_USCORE018(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__S1_USCORE018 * SOAP_FMAC2 soap_instantiate__ns1__S1_USCORE018(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__S1_USCORE018(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__S1_USCORE018, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE018);
		if (size)
			*size = sizeof(_ns1__S1_USCORE018);
		((_ns1__S1_USCORE018*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE018[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__S1_USCORE018);
		for (int i = 0; i < n; i++)
			((_ns1__S1_USCORE018*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__S1_USCORE018*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__S1_USCORE018(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__S1_USCORE018 %p -> %p\n", q, p));
	*(_ns1__S1_USCORE018*)p = *(_ns1__S1_USCORE018*)q;
}

void _ns1__S1_USCORE009Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__S1_USCORE009Response::S1_USCORE009Result = NULL;
	/* transient soap skipped */
}

void _ns1__S1_USCORE009Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__HeartBeatResp(soap, &this->_ns1__S1_USCORE009Response::S1_USCORE009Result);
	/* transient soap skipped */
}

int _ns1__S1_USCORE009Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__S1_USCORE009Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__S1_USCORE009Response(struct soap *soap, const char *tag, int id, const _ns1__S1_USCORE009Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__S1_USCORE009Response), type))
		return soap->error;
	if (a->S1_USCORE009Result)
		soap_element_result(soap, "ns1:S1_009Result");
	if (soap_out_PointerTons1__HeartBeatResp(soap, "ns1:S1_009Result", -1, &(a->_ns1__S1_USCORE009Response::S1_USCORE009Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__S1_USCORE009Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__S1_USCORE009Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__S1_USCORE009Response * SOAP_FMAC4 soap_in__ns1__S1_USCORE009Response(struct soap *soap, const char *tag, _ns1__S1_USCORE009Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__S1_USCORE009Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__S1_USCORE009Response, sizeof(_ns1__S1_USCORE009Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__S1_USCORE009Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__S1_USCORE009Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_S1_USCORE009Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_S1_USCORE009Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__HeartBeatResp(soap, "ns1:S1_009Result", &(a->_ns1__S1_USCORE009Response::S1_USCORE009Result), "ns1:HeartBeatResp"))
				{	soap_flag_S1_USCORE009Result1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:S1_009Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__S1_USCORE009Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__S1_USCORE009Response, 0, sizeof(_ns1__S1_USCORE009Response), 0, soap_copy__ns1__S1_USCORE009Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__S1_USCORE009Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__S1_USCORE009Response);
	if (this->soap_out(soap, tag?tag:"ns1:S1_009Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__S1_USCORE009Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__S1_USCORE009Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__S1_USCORE009Response * SOAP_FMAC4 soap_get__ns1__S1_USCORE009Response(struct soap *soap, _ns1__S1_USCORE009Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__S1_USCORE009Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__S1_USCORE009Response * SOAP_FMAC2 soap_instantiate__ns1__S1_USCORE009Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__S1_USCORE009Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__S1_USCORE009Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE009Response);
		if (size)
			*size = sizeof(_ns1__S1_USCORE009Response);
		((_ns1__S1_USCORE009Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE009Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__S1_USCORE009Response);
		for (int i = 0; i < n; i++)
			((_ns1__S1_USCORE009Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__S1_USCORE009Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__S1_USCORE009Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__S1_USCORE009Response %p -> %p\n", q, p));
	*(_ns1__S1_USCORE009Response*)p = *(_ns1__S1_USCORE009Response*)q;
}

void _ns1__S1_USCORE009::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__S1_USCORE009::heartBeatReq = NULL;
	/* transient soap skipped */
}

void _ns1__S1_USCORE009::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__HeartBeatReq(soap, &this->_ns1__S1_USCORE009::heartBeatReq);
	/* transient soap skipped */
}

int _ns1__S1_USCORE009::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__S1_USCORE009(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__S1_USCORE009(struct soap *soap, const char *tag, int id, const _ns1__S1_USCORE009 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__S1_USCORE009), type))
		return soap->error;
	if (soap_out_PointerTons1__HeartBeatReq(soap, "ns1:heartBeatReq", -1, &(a->_ns1__S1_USCORE009::heartBeatReq), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__S1_USCORE009::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__S1_USCORE009(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__S1_USCORE009 * SOAP_FMAC4 soap_in__ns1__S1_USCORE009(struct soap *soap, const char *tag, _ns1__S1_USCORE009 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__S1_USCORE009 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__S1_USCORE009, sizeof(_ns1__S1_USCORE009), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__S1_USCORE009)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__S1_USCORE009 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_heartBeatReq1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_heartBeatReq1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__HeartBeatReq(soap, "ns1:heartBeatReq", &(a->_ns1__S1_USCORE009::heartBeatReq), "ns1:HeartBeatReq"))
				{	soap_flag_heartBeatReq1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__S1_USCORE009 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__S1_USCORE009, 0, sizeof(_ns1__S1_USCORE009), 0, soap_copy__ns1__S1_USCORE009);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__S1_USCORE009::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__S1_USCORE009);
	if (this->soap_out(soap, tag?tag:"ns1:S1_009", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__S1_USCORE009::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__S1_USCORE009(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__S1_USCORE009 * SOAP_FMAC4 soap_get__ns1__S1_USCORE009(struct soap *soap, _ns1__S1_USCORE009 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__S1_USCORE009(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__S1_USCORE009 * SOAP_FMAC2 soap_instantiate__ns1__S1_USCORE009(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__S1_USCORE009(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__S1_USCORE009, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE009);
		if (size)
			*size = sizeof(_ns1__S1_USCORE009);
		((_ns1__S1_USCORE009*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE009[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__S1_USCORE009);
		for (int i = 0; i < n; i++)
			((_ns1__S1_USCORE009*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__S1_USCORE009*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__S1_USCORE009(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__S1_USCORE009 %p -> %p\n", q, p));
	*(_ns1__S1_USCORE009*)p = *(_ns1__S1_USCORE009*)q;
}

void _ns1__S1_USCORE005Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__S1_USCORE005Response::S1_USCORE005Result = NULL;
	/* transient soap skipped */
}

void _ns1__S1_USCORE005Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__OrderExecuteFaultResp(soap, &this->_ns1__S1_USCORE005Response::S1_USCORE005Result);
	/* transient soap skipped */
}

int _ns1__S1_USCORE005Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__S1_USCORE005Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__S1_USCORE005Response(struct soap *soap, const char *tag, int id, const _ns1__S1_USCORE005Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__S1_USCORE005Response), type))
		return soap->error;
	if (a->S1_USCORE005Result)
		soap_element_result(soap, "ns1:S1_005Result");
	if (soap_out_PointerTons1__OrderExecuteFaultResp(soap, "ns1:S1_005Result", -1, &(a->_ns1__S1_USCORE005Response::S1_USCORE005Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__S1_USCORE005Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__S1_USCORE005Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__S1_USCORE005Response * SOAP_FMAC4 soap_in__ns1__S1_USCORE005Response(struct soap *soap, const char *tag, _ns1__S1_USCORE005Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__S1_USCORE005Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__S1_USCORE005Response, sizeof(_ns1__S1_USCORE005Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__S1_USCORE005Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__S1_USCORE005Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_S1_USCORE005Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_S1_USCORE005Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__OrderExecuteFaultResp(soap, "ns1:S1_005Result", &(a->_ns1__S1_USCORE005Response::S1_USCORE005Result), "ns1:OrderExecuteFaultResp"))
				{	soap_flag_S1_USCORE005Result1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:S1_005Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__S1_USCORE005Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__S1_USCORE005Response, 0, sizeof(_ns1__S1_USCORE005Response), 0, soap_copy__ns1__S1_USCORE005Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__S1_USCORE005Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__S1_USCORE005Response);
	if (this->soap_out(soap, tag?tag:"ns1:S1_005Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__S1_USCORE005Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__S1_USCORE005Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__S1_USCORE005Response * SOAP_FMAC4 soap_get__ns1__S1_USCORE005Response(struct soap *soap, _ns1__S1_USCORE005Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__S1_USCORE005Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__S1_USCORE005Response * SOAP_FMAC2 soap_instantiate__ns1__S1_USCORE005Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__S1_USCORE005Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__S1_USCORE005Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE005Response);
		if (size)
			*size = sizeof(_ns1__S1_USCORE005Response);
		((_ns1__S1_USCORE005Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE005Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__S1_USCORE005Response);
		for (int i = 0; i < n; i++)
			((_ns1__S1_USCORE005Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__S1_USCORE005Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__S1_USCORE005Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__S1_USCORE005Response %p -> %p\n", q, p));
	*(_ns1__S1_USCORE005Response*)p = *(_ns1__S1_USCORE005Response*)q;
}

void _ns1__S1_USCORE005::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__S1_USCORE005::orderExecuteFaultReq = NULL;
	/* transient soap skipped */
}

void _ns1__S1_USCORE005::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__OrderExecuteFaultReq(soap, &this->_ns1__S1_USCORE005::orderExecuteFaultReq);
	/* transient soap skipped */
}

int _ns1__S1_USCORE005::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__S1_USCORE005(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__S1_USCORE005(struct soap *soap, const char *tag, int id, const _ns1__S1_USCORE005 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__S1_USCORE005), type))
		return soap->error;
	if (soap_out_PointerTons1__OrderExecuteFaultReq(soap, "ns1:orderExecuteFaultReq", -1, &(a->_ns1__S1_USCORE005::orderExecuteFaultReq), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__S1_USCORE005::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__S1_USCORE005(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__S1_USCORE005 * SOAP_FMAC4 soap_in__ns1__S1_USCORE005(struct soap *soap, const char *tag, _ns1__S1_USCORE005 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__S1_USCORE005 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__S1_USCORE005, sizeof(_ns1__S1_USCORE005), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__S1_USCORE005)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__S1_USCORE005 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_orderExecuteFaultReq1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_orderExecuteFaultReq1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__OrderExecuteFaultReq(soap, "ns1:orderExecuteFaultReq", &(a->_ns1__S1_USCORE005::orderExecuteFaultReq), "ns1:OrderExecuteFaultReq"))
				{	soap_flag_orderExecuteFaultReq1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__S1_USCORE005 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__S1_USCORE005, 0, sizeof(_ns1__S1_USCORE005), 0, soap_copy__ns1__S1_USCORE005);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__S1_USCORE005::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__S1_USCORE005);
	if (this->soap_out(soap, tag?tag:"ns1:S1_005", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__S1_USCORE005::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__S1_USCORE005(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__S1_USCORE005 * SOAP_FMAC4 soap_get__ns1__S1_USCORE005(struct soap *soap, _ns1__S1_USCORE005 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__S1_USCORE005(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__S1_USCORE005 * SOAP_FMAC2 soap_instantiate__ns1__S1_USCORE005(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__S1_USCORE005(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__S1_USCORE005, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE005);
		if (size)
			*size = sizeof(_ns1__S1_USCORE005);
		((_ns1__S1_USCORE005*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE005[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__S1_USCORE005);
		for (int i = 0; i < n; i++)
			((_ns1__S1_USCORE005*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__S1_USCORE005*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__S1_USCORE005(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__S1_USCORE005 %p -> %p\n", q, p));
	*(_ns1__S1_USCORE005*)p = *(_ns1__S1_USCORE005*)q;
}

void _ns1__S1_USCORE004Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__S1_USCORE004Response::S1_USCORE004Result = NULL;
	/* transient soap skipped */
}

void _ns1__S1_USCORE004Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__OrderExecuteResultResp(soap, &this->_ns1__S1_USCORE004Response::S1_USCORE004Result);
	/* transient soap skipped */
}

int _ns1__S1_USCORE004Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__S1_USCORE004Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__S1_USCORE004Response(struct soap *soap, const char *tag, int id, const _ns1__S1_USCORE004Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__S1_USCORE004Response), type))
		return soap->error;
	if (a->S1_USCORE004Result)
		soap_element_result(soap, "ns1:S1_004Result");
	if (soap_out_PointerTons1__OrderExecuteResultResp(soap, "ns1:S1_004Result", -1, &(a->_ns1__S1_USCORE004Response::S1_USCORE004Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__S1_USCORE004Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__S1_USCORE004Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__S1_USCORE004Response * SOAP_FMAC4 soap_in__ns1__S1_USCORE004Response(struct soap *soap, const char *tag, _ns1__S1_USCORE004Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__S1_USCORE004Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__S1_USCORE004Response, sizeof(_ns1__S1_USCORE004Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__S1_USCORE004Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__S1_USCORE004Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_S1_USCORE004Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_S1_USCORE004Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__OrderExecuteResultResp(soap, "ns1:S1_004Result", &(a->_ns1__S1_USCORE004Response::S1_USCORE004Result), "ns1:OrderExecuteResultResp"))
				{	soap_flag_S1_USCORE004Result1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:S1_004Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__S1_USCORE004Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__S1_USCORE004Response, 0, sizeof(_ns1__S1_USCORE004Response), 0, soap_copy__ns1__S1_USCORE004Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__S1_USCORE004Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__S1_USCORE004Response);
	if (this->soap_out(soap, tag?tag:"ns1:S1_004Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__S1_USCORE004Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__S1_USCORE004Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__S1_USCORE004Response * SOAP_FMAC4 soap_get__ns1__S1_USCORE004Response(struct soap *soap, _ns1__S1_USCORE004Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__S1_USCORE004Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__S1_USCORE004Response * SOAP_FMAC2 soap_instantiate__ns1__S1_USCORE004Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__S1_USCORE004Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__S1_USCORE004Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE004Response);
		if (size)
			*size = sizeof(_ns1__S1_USCORE004Response);
		((_ns1__S1_USCORE004Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE004Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__S1_USCORE004Response);
		for (int i = 0; i < n; i++)
			((_ns1__S1_USCORE004Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__S1_USCORE004Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__S1_USCORE004Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__S1_USCORE004Response %p -> %p\n", q, p));
	*(_ns1__S1_USCORE004Response*)p = *(_ns1__S1_USCORE004Response*)q;
}

void _ns1__S1_USCORE004::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__S1_USCORE004::orderExecuteResultReq = NULL;
	/* transient soap skipped */
}

void _ns1__S1_USCORE004::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__OrderExecuteResultReq(soap, &this->_ns1__S1_USCORE004::orderExecuteResultReq);
	/* transient soap skipped */
}

int _ns1__S1_USCORE004::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__S1_USCORE004(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__S1_USCORE004(struct soap *soap, const char *tag, int id, const _ns1__S1_USCORE004 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__S1_USCORE004), type))
		return soap->error;
	if (soap_out_PointerTons1__OrderExecuteResultReq(soap, "ns1:orderExecuteResultReq", -1, &(a->_ns1__S1_USCORE004::orderExecuteResultReq), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__S1_USCORE004::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__S1_USCORE004(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__S1_USCORE004 * SOAP_FMAC4 soap_in__ns1__S1_USCORE004(struct soap *soap, const char *tag, _ns1__S1_USCORE004 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__S1_USCORE004 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__S1_USCORE004, sizeof(_ns1__S1_USCORE004), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__S1_USCORE004)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__S1_USCORE004 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_orderExecuteResultReq1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_orderExecuteResultReq1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__OrderExecuteResultReq(soap, "ns1:orderExecuteResultReq", &(a->_ns1__S1_USCORE004::orderExecuteResultReq), "ns1:OrderExecuteResultReq"))
				{	soap_flag_orderExecuteResultReq1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__S1_USCORE004 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__S1_USCORE004, 0, sizeof(_ns1__S1_USCORE004), 0, soap_copy__ns1__S1_USCORE004);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__S1_USCORE004::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__S1_USCORE004);
	if (this->soap_out(soap, tag?tag:"ns1:S1_004", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__S1_USCORE004::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__S1_USCORE004(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__S1_USCORE004 * SOAP_FMAC4 soap_get__ns1__S1_USCORE004(struct soap *soap, _ns1__S1_USCORE004 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__S1_USCORE004(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__S1_USCORE004 * SOAP_FMAC2 soap_instantiate__ns1__S1_USCORE004(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__S1_USCORE004(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__S1_USCORE004, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE004);
		if (size)
			*size = sizeof(_ns1__S1_USCORE004);
		((_ns1__S1_USCORE004*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE004[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__S1_USCORE004);
		for (int i = 0; i < n; i++)
			((_ns1__S1_USCORE004*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__S1_USCORE004*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__S1_USCORE004(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__S1_USCORE004 %p -> %p\n", q, p));
	*(_ns1__S1_USCORE004*)p = *(_ns1__S1_USCORE004*)q;
}

void _ns1__S1_USCORE001Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__S1_USCORE001Response::S1_USCORE001Result = NULL;
	/* transient soap skipped */
}

void _ns1__S1_USCORE001Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__OrderCommitResp(soap, &this->_ns1__S1_USCORE001Response::S1_USCORE001Result);
	/* transient soap skipped */
}

int _ns1__S1_USCORE001Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__S1_USCORE001Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__S1_USCORE001Response(struct soap *soap, const char *tag, int id, const _ns1__S1_USCORE001Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__S1_USCORE001Response), type))
		return soap->error;
	if (a->S1_USCORE001Result)
		soap_element_result(soap, "ns1:S1_001Result");
	if (soap_out_PointerTons1__OrderCommitResp(soap, "ns1:S1_001Result", -1, &(a->_ns1__S1_USCORE001Response::S1_USCORE001Result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__S1_USCORE001Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__S1_USCORE001Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__S1_USCORE001Response * SOAP_FMAC4 soap_in__ns1__S1_USCORE001Response(struct soap *soap, const char *tag, _ns1__S1_USCORE001Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__S1_USCORE001Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__S1_USCORE001Response, sizeof(_ns1__S1_USCORE001Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__S1_USCORE001Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__S1_USCORE001Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_S1_USCORE001Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_S1_USCORE001Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__OrderCommitResp(soap, "ns1:S1_001Result", &(a->_ns1__S1_USCORE001Response::S1_USCORE001Result), "ns1:OrderCommitResp"))
				{	soap_flag_S1_USCORE001Result1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:S1_001Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__S1_USCORE001Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__S1_USCORE001Response, 0, sizeof(_ns1__S1_USCORE001Response), 0, soap_copy__ns1__S1_USCORE001Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__S1_USCORE001Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__S1_USCORE001Response);
	if (this->soap_out(soap, tag?tag:"ns1:S1_001Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__S1_USCORE001Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__S1_USCORE001Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__S1_USCORE001Response * SOAP_FMAC4 soap_get__ns1__S1_USCORE001Response(struct soap *soap, _ns1__S1_USCORE001Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__S1_USCORE001Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__S1_USCORE001Response * SOAP_FMAC2 soap_instantiate__ns1__S1_USCORE001Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__S1_USCORE001Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__S1_USCORE001Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE001Response);
		if (size)
			*size = sizeof(_ns1__S1_USCORE001Response);
		((_ns1__S1_USCORE001Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE001Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__S1_USCORE001Response);
		for (int i = 0; i < n; i++)
			((_ns1__S1_USCORE001Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__S1_USCORE001Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__S1_USCORE001Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__S1_USCORE001Response %p -> %p\n", q, p));
	*(_ns1__S1_USCORE001Response*)p = *(_ns1__S1_USCORE001Response*)q;
}

void _ns1__S1_USCORE001::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__S1_USCORE001::orderCommitReq = NULL;
	/* transient soap skipped */
}

void _ns1__S1_USCORE001::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__OrderCommitReq(soap, &this->_ns1__S1_USCORE001::orderCommitReq);
	/* transient soap skipped */
}

int _ns1__S1_USCORE001::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__S1_USCORE001(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__S1_USCORE001(struct soap *soap, const char *tag, int id, const _ns1__S1_USCORE001 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__S1_USCORE001), type))
		return soap->error;
	if (soap_out_PointerTons1__OrderCommitReq(soap, "ns1:orderCommitReq", -1, &(a->_ns1__S1_USCORE001::orderCommitReq), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__S1_USCORE001::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__S1_USCORE001(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__S1_USCORE001 * SOAP_FMAC4 soap_in__ns1__S1_USCORE001(struct soap *soap, const char *tag, _ns1__S1_USCORE001 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__S1_USCORE001 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__S1_USCORE001, sizeof(_ns1__S1_USCORE001), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__S1_USCORE001)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__S1_USCORE001 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_orderCommitReq1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_orderCommitReq1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__OrderCommitReq(soap, "ns1:orderCommitReq", &(a->_ns1__S1_USCORE001::orderCommitReq), "ns1:OrderCommitReq"))
				{	soap_flag_orderCommitReq1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__S1_USCORE001 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__S1_USCORE001, 0, sizeof(_ns1__S1_USCORE001), 0, soap_copy__ns1__S1_USCORE001);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__S1_USCORE001::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__S1_USCORE001);
	if (this->soap_out(soap, tag?tag:"ns1:S1_001", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__S1_USCORE001::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__S1_USCORE001(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__S1_USCORE001 * SOAP_FMAC4 soap_get__ns1__S1_USCORE001(struct soap *soap, _ns1__S1_USCORE001 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__S1_USCORE001(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__S1_USCORE001 * SOAP_FMAC2 soap_instantiate__ns1__S1_USCORE001(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__S1_USCORE001(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__S1_USCORE001, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE001);
		if (size)
			*size = sizeof(_ns1__S1_USCORE001);
		((_ns1__S1_USCORE001*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__S1_USCORE001[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__S1_USCORE001);
		for (int i = 0; i < n; i++)
			((_ns1__S1_USCORE001*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__S1_USCORE001*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__S1_USCORE001(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__S1_USCORE001 %p -> %p\n", q, p));
	*(_ns1__S1_USCORE001*)p = *(_ns1__S1_USCORE001*)q;
}

void ns1__SnapQRCodeTakeOrderQueryResp::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::respCode);
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::respCodeMemo);
	this->ns1__SnapQRCodeTakeOrderQueryResp::expandAttribute = NULL;
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::paymentAccount);
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::orderNo);
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::pickupStationCode);
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::getOffStationCode);
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::singleTicketPrice);
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::singleTicketNum);
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::singleTicketType);
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::deviceId);
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::userName);
	/* transient soap skipped */
}

void ns1__SnapQRCodeTakeOrderQueryResp::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::respCode);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::respCodeMemo);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::expandAttribute);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::paymentAccount);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::orderNo);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::pickupStationCode);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::getOffStationCode);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::singleTicketPrice);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::singleTicketNum);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::singleTicketType);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::deviceId);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryResp::userName);
	/* transient soap skipped */
}

int ns1__SnapQRCodeTakeOrderQueryResp::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SnapQRCodeTakeOrderQueryResp(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SnapQRCodeTakeOrderQueryResp(struct soap *soap, const char *tag, int id, const ns1__SnapQRCodeTakeOrderQueryResp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp), "ns1:SnapQRCodeTakeOrderQueryResp"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:respCode", -1, &(a->ns1__SnapQRCodeTakeOrderQueryResp::respCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:respCodeMemo", -1, &(a->ns1__SnapQRCodeTakeOrderQueryResp::respCodeMemo), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", -1, &(a->ns1__SnapQRCodeTakeOrderQueryResp::expandAttribute), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:paymentAccount", -1, &(a->ns1__SnapQRCodeTakeOrderQueryResp::paymentAccount), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:orderNo", -1, &(a->ns1__SnapQRCodeTakeOrderQueryResp::orderNo), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:pickupStationCode", -1, &(a->ns1__SnapQRCodeTakeOrderQueryResp::pickupStationCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:getOffStationCode", -1, &(a->ns1__SnapQRCodeTakeOrderQueryResp::getOffStationCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:singleTicketPrice", -1, &(a->ns1__SnapQRCodeTakeOrderQueryResp::singleTicketPrice), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:singleTicketNum", -1, &(a->ns1__SnapQRCodeTakeOrderQueryResp::singleTicketNum), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:singleTicketType", -1, &(a->ns1__SnapQRCodeTakeOrderQueryResp::singleTicketType), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:deviceId", -1, &(a->ns1__SnapQRCodeTakeOrderQueryResp::deviceId), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->ns1__SnapQRCodeTakeOrderQueryResp::userName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SnapQRCodeTakeOrderQueryResp::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SnapQRCodeTakeOrderQueryResp(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SnapQRCodeTakeOrderQueryResp * SOAP_FMAC4 soap_in_ns1__SnapQRCodeTakeOrderQueryResp(struct soap *soap, const char *tag, ns1__SnapQRCodeTakeOrderQueryResp *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SnapQRCodeTakeOrderQueryResp *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp, sizeof(ns1__SnapQRCodeTakeOrderQueryResp), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SnapQRCodeTakeOrderQueryResp *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_respCode1 = 1;
	size_t soap_flag_respCodeMemo1 = 1;
	size_t soap_flag_expandAttribute1 = 1;
	size_t soap_flag_paymentAccount1 = 1;
	size_t soap_flag_orderNo1 = 1;
	size_t soap_flag_pickupStationCode1 = 1;
	size_t soap_flag_getOffStationCode1 = 1;
	size_t soap_flag_singleTicketPrice1 = 1;
	size_t soap_flag_singleTicketNum1 = 1;
	size_t soap_flag_singleTicketType1 = 1;
	size_t soap_flag_deviceId1 = 1;
	size_t soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_respCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:respCode", &(a->ns1__SnapQRCodeTakeOrderQueryResp::respCode), "xsd:string"))
				{	soap_flag_respCode1--;
					continue;
				}
			if (soap_flag_respCodeMemo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:respCodeMemo", &(a->ns1__SnapQRCodeTakeOrderQueryResp::respCodeMemo), "xsd:string"))
				{	soap_flag_respCodeMemo1--;
					continue;
				}
			if (soap_flag_expandAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", &(a->ns1__SnapQRCodeTakeOrderQueryResp::expandAttribute), "ns1:ArrayOfString"))
				{	soap_flag_expandAttribute1--;
					continue;
				}
			if (soap_flag_paymentAccount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:paymentAccount", &(a->ns1__SnapQRCodeTakeOrderQueryResp::paymentAccount), "xsd:string"))
				{	soap_flag_paymentAccount1--;
					continue;
				}
			if (soap_flag_orderNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:orderNo", &(a->ns1__SnapQRCodeTakeOrderQueryResp::orderNo), "xsd:string"))
				{	soap_flag_orderNo1--;
					continue;
				}
			if (soap_flag_pickupStationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:pickupStationCode", &(a->ns1__SnapQRCodeTakeOrderQueryResp::pickupStationCode), "xsd:string"))
				{	soap_flag_pickupStationCode1--;
					continue;
				}
			if (soap_flag_getOffStationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:getOffStationCode", &(a->ns1__SnapQRCodeTakeOrderQueryResp::getOffStationCode), "xsd:string"))
				{	soap_flag_getOffStationCode1--;
					continue;
				}
			if (soap_flag_singleTicketPrice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:singleTicketPrice", &(a->ns1__SnapQRCodeTakeOrderQueryResp::singleTicketPrice), "xsd:string"))
				{	soap_flag_singleTicketPrice1--;
					continue;
				}
			if (soap_flag_singleTicketNum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:singleTicketNum", &(a->ns1__SnapQRCodeTakeOrderQueryResp::singleTicketNum), "xsd:string"))
				{	soap_flag_singleTicketNum1--;
					continue;
				}
			if (soap_flag_singleTicketType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:singleTicketType", &(a->ns1__SnapQRCodeTakeOrderQueryResp::singleTicketType), "xsd:string"))
				{	soap_flag_singleTicketType1--;
					continue;
				}
			if (soap_flag_deviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:deviceId", &(a->ns1__SnapQRCodeTakeOrderQueryResp::deviceId), "xsd:string"))
				{	soap_flag_deviceId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->ns1__SnapQRCodeTakeOrderQueryResp::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SnapQRCodeTakeOrderQueryResp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp, 0, sizeof(ns1__SnapQRCodeTakeOrderQueryResp), 0, soap_copy_ns1__SnapQRCodeTakeOrderQueryResp);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SnapQRCodeTakeOrderQueryResp::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp);
	if (this->soap_out(soap, tag?tag:"ns1:SnapQRCodeTakeOrderQueryResp", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SnapQRCodeTakeOrderQueryResp::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SnapQRCodeTakeOrderQueryResp(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SnapQRCodeTakeOrderQueryResp * SOAP_FMAC4 soap_get_ns1__SnapQRCodeTakeOrderQueryResp(struct soap *soap, ns1__SnapQRCodeTakeOrderQueryResp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SnapQRCodeTakeOrderQueryResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SnapQRCodeTakeOrderQueryResp * SOAP_FMAC2 soap_instantiate_ns1__SnapQRCodeTakeOrderQueryResp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SnapQRCodeTakeOrderQueryResp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodeTakeOrderQueryResp);
		if (size)
			*size = sizeof(ns1__SnapQRCodeTakeOrderQueryResp);
		((ns1__SnapQRCodeTakeOrderQueryResp*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodeTakeOrderQueryResp[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SnapQRCodeTakeOrderQueryResp);
		for (int i = 0; i < n; i++)
			((ns1__SnapQRCodeTakeOrderQueryResp*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SnapQRCodeTakeOrderQueryResp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SnapQRCodeTakeOrderQueryResp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SnapQRCodeTakeOrderQueryResp %p -> %p\n", q, p));
	*(ns1__SnapQRCodeTakeOrderQueryResp*)p = *(ns1__SnapQRCodeTakeOrderQueryResp*)q;
}

void ns1__SnapQRCodeTakeOrderQueryReq::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryReq::reqSysDate);
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryReq::operationCode);
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryReq::cityCode);
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryReq::deviceId);
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryReq::channelType);
	this->ns1__SnapQRCodeTakeOrderQueryReq::expandAttribute = NULL;
	soap_default_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryReq::randomFact);
	/* transient soap skipped */
}

void ns1__SnapQRCodeTakeOrderQueryReq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryReq::reqSysDate);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryReq::operationCode);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryReq::cityCode);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryReq::deviceId);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryReq::channelType);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__SnapQRCodeTakeOrderQueryReq::expandAttribute);
	soap_serialize_string(soap, &this->ns1__SnapQRCodeTakeOrderQueryReq::randomFact);
	/* transient soap skipped */
}

int ns1__SnapQRCodeTakeOrderQueryReq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SnapQRCodeTakeOrderQueryReq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SnapQRCodeTakeOrderQueryReq(struct soap *soap, const char *tag, int id, const ns1__SnapQRCodeTakeOrderQueryReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq), "ns1:SnapQRCodeTakeOrderQueryReq"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:reqSysDate", -1, &(a->ns1__SnapQRCodeTakeOrderQueryReq::reqSysDate), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:operationCode", -1, &(a->ns1__SnapQRCodeTakeOrderQueryReq::operationCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:cityCode", -1, &(a->ns1__SnapQRCodeTakeOrderQueryReq::cityCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:deviceId", -1, &(a->ns1__SnapQRCodeTakeOrderQueryReq::deviceId), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:channelType", -1, &(a->ns1__SnapQRCodeTakeOrderQueryReq::channelType), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", -1, &(a->ns1__SnapQRCodeTakeOrderQueryReq::expandAttribute), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:randomFact", -1, &(a->ns1__SnapQRCodeTakeOrderQueryReq::randomFact), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SnapQRCodeTakeOrderQueryReq::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SnapQRCodeTakeOrderQueryReq(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SnapQRCodeTakeOrderQueryReq * SOAP_FMAC4 soap_in_ns1__SnapQRCodeTakeOrderQueryReq(struct soap *soap, const char *tag, ns1__SnapQRCodeTakeOrderQueryReq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SnapQRCodeTakeOrderQueryReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq, sizeof(ns1__SnapQRCodeTakeOrderQueryReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SnapQRCodeTakeOrderQueryReq *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_reqSysDate1 = 1;
	size_t soap_flag_operationCode1 = 1;
	size_t soap_flag_cityCode1 = 1;
	size_t soap_flag_deviceId1 = 1;
	size_t soap_flag_channelType1 = 1;
	size_t soap_flag_expandAttribute1 = 1;
	size_t soap_flag_randomFact1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_reqSysDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:reqSysDate", &(a->ns1__SnapQRCodeTakeOrderQueryReq::reqSysDate), "xsd:string"))
				{	soap_flag_reqSysDate1--;
					continue;
				}
			if (soap_flag_operationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operationCode", &(a->ns1__SnapQRCodeTakeOrderQueryReq::operationCode), "xsd:string"))
				{	soap_flag_operationCode1--;
					continue;
				}
			if (soap_flag_cityCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cityCode", &(a->ns1__SnapQRCodeTakeOrderQueryReq::cityCode), "xsd:string"))
				{	soap_flag_cityCode1--;
					continue;
				}
			if (soap_flag_deviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:deviceId", &(a->ns1__SnapQRCodeTakeOrderQueryReq::deviceId), "xsd:string"))
				{	soap_flag_deviceId1--;
					continue;
				}
			if (soap_flag_channelType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:channelType", &(a->ns1__SnapQRCodeTakeOrderQueryReq::channelType), "xsd:string"))
				{	soap_flag_channelType1--;
					continue;
				}
			if (soap_flag_expandAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", &(a->ns1__SnapQRCodeTakeOrderQueryReq::expandAttribute), "ns1:ArrayOfString"))
				{	soap_flag_expandAttribute1--;
					continue;
				}
			if (soap_flag_randomFact1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:randomFact", &(a->ns1__SnapQRCodeTakeOrderQueryReq::randomFact), "xsd:string"))
				{	soap_flag_randomFact1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SnapQRCodeTakeOrderQueryReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq, 0, sizeof(ns1__SnapQRCodeTakeOrderQueryReq), 0, soap_copy_ns1__SnapQRCodeTakeOrderQueryReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SnapQRCodeTakeOrderQueryReq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq);
	if (this->soap_out(soap, tag?tag:"ns1:SnapQRCodeTakeOrderQueryReq", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SnapQRCodeTakeOrderQueryReq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SnapQRCodeTakeOrderQueryReq(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SnapQRCodeTakeOrderQueryReq * SOAP_FMAC4 soap_get_ns1__SnapQRCodeTakeOrderQueryReq(struct soap *soap, ns1__SnapQRCodeTakeOrderQueryReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SnapQRCodeTakeOrderQueryReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SnapQRCodeTakeOrderQueryReq * SOAP_FMAC2 soap_instantiate_ns1__SnapQRCodeTakeOrderQueryReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SnapQRCodeTakeOrderQueryReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodeTakeOrderQueryReq);
		if (size)
			*size = sizeof(ns1__SnapQRCodeTakeOrderQueryReq);
		((ns1__SnapQRCodeTakeOrderQueryReq*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodeTakeOrderQueryReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SnapQRCodeTakeOrderQueryReq);
		for (int i = 0; i < n; i++)
			((ns1__SnapQRCodeTakeOrderQueryReq*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SnapQRCodeTakeOrderQueryReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SnapQRCodeTakeOrderQueryReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SnapQRCodeTakeOrderQueryReq %p -> %p\n", q, p));
	*(ns1__SnapQRCodeTakeOrderQueryReq*)p = *(ns1__SnapQRCodeTakeOrderQueryReq*)q;
}

void ns1__SnapQRCodePayResultQueryResp::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::respCode);
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::respCodeMemo);
	this->ns1__SnapQRCodePayResultQueryResp::expandAttribute = NULL;
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::orderNo);
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::paymentDate);
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::amount);
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::paymentAccount);
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::paymentResult);
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::paymentDesc);
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::userName);
	/* transient soap skipped */
}

void ns1__SnapQRCodePayResultQueryResp::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::respCode);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::respCodeMemo);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__SnapQRCodePayResultQueryResp::expandAttribute);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::orderNo);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::paymentDate);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::amount);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::paymentAccount);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::paymentResult);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::paymentDesc);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryResp::userName);
	/* transient soap skipped */
}

int ns1__SnapQRCodePayResultQueryResp::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SnapQRCodePayResultQueryResp(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SnapQRCodePayResultQueryResp(struct soap *soap, const char *tag, int id, const ns1__SnapQRCodePayResultQueryResp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp), "ns1:SnapQRCodePayResultQueryResp"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:respCode", -1, &(a->ns1__SnapQRCodePayResultQueryResp::respCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:respCodeMemo", -1, &(a->ns1__SnapQRCodePayResultQueryResp::respCodeMemo), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", -1, &(a->ns1__SnapQRCodePayResultQueryResp::expandAttribute), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:orderNo", -1, &(a->ns1__SnapQRCodePayResultQueryResp::orderNo), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:paymentDate", -1, &(a->ns1__SnapQRCodePayResultQueryResp::paymentDate), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:amount", -1, &(a->ns1__SnapQRCodePayResultQueryResp::amount), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:paymentAccount", -1, &(a->ns1__SnapQRCodePayResultQueryResp::paymentAccount), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:paymentResult", -1, &(a->ns1__SnapQRCodePayResultQueryResp::paymentResult), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:paymentDesc", -1, &(a->ns1__SnapQRCodePayResultQueryResp::paymentDesc), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->ns1__SnapQRCodePayResultQueryResp::userName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SnapQRCodePayResultQueryResp::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SnapQRCodePayResultQueryResp(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SnapQRCodePayResultQueryResp * SOAP_FMAC4 soap_in_ns1__SnapQRCodePayResultQueryResp(struct soap *soap, const char *tag, ns1__SnapQRCodePayResultQueryResp *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SnapQRCodePayResultQueryResp *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp, sizeof(ns1__SnapQRCodePayResultQueryResp), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SnapQRCodePayResultQueryResp *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_respCode1 = 1;
	size_t soap_flag_respCodeMemo1 = 1;
	size_t soap_flag_expandAttribute1 = 1;
	size_t soap_flag_orderNo1 = 1;
	size_t soap_flag_paymentDate1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_paymentAccount1 = 1;
	size_t soap_flag_paymentResult1 = 1;
	size_t soap_flag_paymentDesc1 = 1;
	size_t soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_respCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:respCode", &(a->ns1__SnapQRCodePayResultQueryResp::respCode), "xsd:string"))
				{	soap_flag_respCode1--;
					continue;
				}
			if (soap_flag_respCodeMemo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:respCodeMemo", &(a->ns1__SnapQRCodePayResultQueryResp::respCodeMemo), "xsd:string"))
				{	soap_flag_respCodeMemo1--;
					continue;
				}
			if (soap_flag_expandAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", &(a->ns1__SnapQRCodePayResultQueryResp::expandAttribute), "ns1:ArrayOfString"))
				{	soap_flag_expandAttribute1--;
					continue;
				}
			if (soap_flag_orderNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:orderNo", &(a->ns1__SnapQRCodePayResultQueryResp::orderNo), "xsd:string"))
				{	soap_flag_orderNo1--;
					continue;
				}
			if (soap_flag_paymentDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:paymentDate", &(a->ns1__SnapQRCodePayResultQueryResp::paymentDate), "xsd:string"))
				{	soap_flag_paymentDate1--;
					continue;
				}
			if (soap_flag_amount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:amount", &(a->ns1__SnapQRCodePayResultQueryResp::amount), "xsd:string"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_paymentAccount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:paymentAccount", &(a->ns1__SnapQRCodePayResultQueryResp::paymentAccount), "xsd:string"))
				{	soap_flag_paymentAccount1--;
					continue;
				}
			if (soap_flag_paymentResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:paymentResult", &(a->ns1__SnapQRCodePayResultQueryResp::paymentResult), "xsd:string"))
				{	soap_flag_paymentResult1--;
					continue;
				}
			if (soap_flag_paymentDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:paymentDesc", &(a->ns1__SnapQRCodePayResultQueryResp::paymentDesc), "xsd:string"))
				{	soap_flag_paymentDesc1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->ns1__SnapQRCodePayResultQueryResp::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SnapQRCodePayResultQueryResp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp, 0, sizeof(ns1__SnapQRCodePayResultQueryResp), 0, soap_copy_ns1__SnapQRCodePayResultQueryResp);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SnapQRCodePayResultQueryResp::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp);
	if (this->soap_out(soap, tag?tag:"ns1:SnapQRCodePayResultQueryResp", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SnapQRCodePayResultQueryResp::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SnapQRCodePayResultQueryResp(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SnapQRCodePayResultQueryResp * SOAP_FMAC4 soap_get_ns1__SnapQRCodePayResultQueryResp(struct soap *soap, ns1__SnapQRCodePayResultQueryResp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SnapQRCodePayResultQueryResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SnapQRCodePayResultQueryResp * SOAP_FMAC2 soap_instantiate_ns1__SnapQRCodePayResultQueryResp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SnapQRCodePayResultQueryResp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePayResultQueryResp);
		if (size)
			*size = sizeof(ns1__SnapQRCodePayResultQueryResp);
		((ns1__SnapQRCodePayResultQueryResp*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePayResultQueryResp[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SnapQRCodePayResultQueryResp);
		for (int i = 0; i < n; i++)
			((ns1__SnapQRCodePayResultQueryResp*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SnapQRCodePayResultQueryResp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SnapQRCodePayResultQueryResp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SnapQRCodePayResultQueryResp %p -> %p\n", q, p));
	*(ns1__SnapQRCodePayResultQueryResp*)p = *(ns1__SnapQRCodePayResultQueryResp*)q;
}

void ns1__SnapQRCodePayResultQueryReq::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryReq::reqSysDate);
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryReq::operationCode);
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryReq::cityCode);
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryReq::deviceId);
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryReq::channelType);
	this->ns1__SnapQRCodePayResultQueryReq::expandAttribute = NULL;
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryReq::orderNo);
	soap_default_string(soap, &this->ns1__SnapQRCodePayResultQueryReq::qrCode);
	/* transient soap skipped */
}

void ns1__SnapQRCodePayResultQueryReq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryReq::reqSysDate);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryReq::operationCode);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryReq::cityCode);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryReq::deviceId);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryReq::channelType);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__SnapQRCodePayResultQueryReq::expandAttribute);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryReq::orderNo);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePayResultQueryReq::qrCode);
	/* transient soap skipped */
}

int ns1__SnapQRCodePayResultQueryReq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SnapQRCodePayResultQueryReq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SnapQRCodePayResultQueryReq(struct soap *soap, const char *tag, int id, const ns1__SnapQRCodePayResultQueryReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq), "ns1:SnapQRCodePayResultQueryReq"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:reqSysDate", -1, &(a->ns1__SnapQRCodePayResultQueryReq::reqSysDate), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:operationCode", -1, &(a->ns1__SnapQRCodePayResultQueryReq::operationCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:cityCode", -1, &(a->ns1__SnapQRCodePayResultQueryReq::cityCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:deviceId", -1, &(a->ns1__SnapQRCodePayResultQueryReq::deviceId), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:channelType", -1, &(a->ns1__SnapQRCodePayResultQueryReq::channelType), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", -1, &(a->ns1__SnapQRCodePayResultQueryReq::expandAttribute), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:orderNo", -1, &(a->ns1__SnapQRCodePayResultQueryReq::orderNo), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:qrCode", -1, &(a->ns1__SnapQRCodePayResultQueryReq::qrCode), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SnapQRCodePayResultQueryReq::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SnapQRCodePayResultQueryReq(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SnapQRCodePayResultQueryReq * SOAP_FMAC4 soap_in_ns1__SnapQRCodePayResultQueryReq(struct soap *soap, const char *tag, ns1__SnapQRCodePayResultQueryReq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SnapQRCodePayResultQueryReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq, sizeof(ns1__SnapQRCodePayResultQueryReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SnapQRCodePayResultQueryReq *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_reqSysDate1 = 1;
	size_t soap_flag_operationCode1 = 1;
	size_t soap_flag_cityCode1 = 1;
	size_t soap_flag_deviceId1 = 1;
	size_t soap_flag_channelType1 = 1;
	size_t soap_flag_expandAttribute1 = 1;
	size_t soap_flag_orderNo1 = 1;
	size_t soap_flag_qrCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_reqSysDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:reqSysDate", &(a->ns1__SnapQRCodePayResultQueryReq::reqSysDate), "xsd:string"))
				{	soap_flag_reqSysDate1--;
					continue;
				}
			if (soap_flag_operationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operationCode", &(a->ns1__SnapQRCodePayResultQueryReq::operationCode), "xsd:string"))
				{	soap_flag_operationCode1--;
					continue;
				}
			if (soap_flag_cityCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cityCode", &(a->ns1__SnapQRCodePayResultQueryReq::cityCode), "xsd:string"))
				{	soap_flag_cityCode1--;
					continue;
				}
			if (soap_flag_deviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:deviceId", &(a->ns1__SnapQRCodePayResultQueryReq::deviceId), "xsd:string"))
				{	soap_flag_deviceId1--;
					continue;
				}
			if (soap_flag_channelType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:channelType", &(a->ns1__SnapQRCodePayResultQueryReq::channelType), "xsd:string"))
				{	soap_flag_channelType1--;
					continue;
				}
			if (soap_flag_expandAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", &(a->ns1__SnapQRCodePayResultQueryReq::expandAttribute), "ns1:ArrayOfString"))
				{	soap_flag_expandAttribute1--;
					continue;
				}
			if (soap_flag_orderNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:orderNo", &(a->ns1__SnapQRCodePayResultQueryReq::orderNo), "xsd:string"))
				{	soap_flag_orderNo1--;
					continue;
				}
			if (soap_flag_qrCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:qrCode", &(a->ns1__SnapQRCodePayResultQueryReq::qrCode), "xsd:string"))
				{	soap_flag_qrCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SnapQRCodePayResultQueryReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq, 0, sizeof(ns1__SnapQRCodePayResultQueryReq), 0, soap_copy_ns1__SnapQRCodePayResultQueryReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SnapQRCodePayResultQueryReq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq);
	if (this->soap_out(soap, tag?tag:"ns1:SnapQRCodePayResultQueryReq", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SnapQRCodePayResultQueryReq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SnapQRCodePayResultQueryReq(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SnapQRCodePayResultQueryReq * SOAP_FMAC4 soap_get_ns1__SnapQRCodePayResultQueryReq(struct soap *soap, ns1__SnapQRCodePayResultQueryReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SnapQRCodePayResultQueryReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SnapQRCodePayResultQueryReq * SOAP_FMAC2 soap_instantiate_ns1__SnapQRCodePayResultQueryReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SnapQRCodePayResultQueryReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePayResultQueryReq);
		if (size)
			*size = sizeof(ns1__SnapQRCodePayResultQueryReq);
		((ns1__SnapQRCodePayResultQueryReq*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePayResultQueryReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SnapQRCodePayResultQueryReq);
		for (int i = 0; i < n; i++)
			((ns1__SnapQRCodePayResultQueryReq*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SnapQRCodePayResultQueryReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SnapQRCodePayResultQueryReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SnapQRCodePayResultQueryReq %p -> %p\n", q, p));
	*(ns1__SnapQRCodePayResultQueryReq*)p = *(ns1__SnapQRCodePayResultQueryReq*)q;
}

void ns1__SnapQRCodePrePayURLQueryResp::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__SnapQRCodePrePayURLQueryResp::respCode);
	soap_default_string(soap, &this->ns1__SnapQRCodePrePayURLQueryResp::respCodeMemo);
	this->ns1__SnapQRCodePrePayURLQueryResp::expandAttribute = NULL;
	soap_default_string(soap, &this->ns1__SnapQRCodePrePayURLQueryResp::orderNo);
	soap_default_string(soap, &this->ns1__SnapQRCodePrePayURLQueryResp::deviceId);
	soap_default_string(soap, &this->ns1__SnapQRCodePrePayURLQueryResp::qrCode);
	/* transient soap skipped */
}

void ns1__SnapQRCodePrePayURLQueryResp::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__SnapQRCodePrePayURLQueryResp::respCode);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePrePayURLQueryResp::respCodeMemo);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__SnapQRCodePrePayURLQueryResp::expandAttribute);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePrePayURLQueryResp::orderNo);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePrePayURLQueryResp::deviceId);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePrePayURLQueryResp::qrCode);
	/* transient soap skipped */
}

int ns1__SnapQRCodePrePayURLQueryResp::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SnapQRCodePrePayURLQueryResp(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SnapQRCodePrePayURLQueryResp(struct soap *soap, const char *tag, int id, const ns1__SnapQRCodePrePayURLQueryResp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp), "ns1:SnapQRCodePrePayURLQueryResp"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:respCode", -1, &(a->ns1__SnapQRCodePrePayURLQueryResp::respCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:respCodeMemo", -1, &(a->ns1__SnapQRCodePrePayURLQueryResp::respCodeMemo), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", -1, &(a->ns1__SnapQRCodePrePayURLQueryResp::expandAttribute), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:orderNo", -1, &(a->ns1__SnapQRCodePrePayURLQueryResp::orderNo), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:deviceId", -1, &(a->ns1__SnapQRCodePrePayURLQueryResp::deviceId), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:qrCode", -1, &(a->ns1__SnapQRCodePrePayURLQueryResp::qrCode), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SnapQRCodePrePayURLQueryResp::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SnapQRCodePrePayURLQueryResp(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SnapQRCodePrePayURLQueryResp * SOAP_FMAC4 soap_in_ns1__SnapQRCodePrePayURLQueryResp(struct soap *soap, const char *tag, ns1__SnapQRCodePrePayURLQueryResp *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SnapQRCodePrePayURLQueryResp *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp, sizeof(ns1__SnapQRCodePrePayURLQueryResp), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SnapQRCodePrePayURLQueryResp *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_respCode1 = 1;
	size_t soap_flag_respCodeMemo1 = 1;
	size_t soap_flag_expandAttribute1 = 1;
	size_t soap_flag_orderNo1 = 1;
	size_t soap_flag_deviceId1 = 1;
	size_t soap_flag_qrCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_respCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:respCode", &(a->ns1__SnapQRCodePrePayURLQueryResp::respCode), "xsd:string"))
				{	soap_flag_respCode1--;
					continue;
				}
			if (soap_flag_respCodeMemo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:respCodeMemo", &(a->ns1__SnapQRCodePrePayURLQueryResp::respCodeMemo), "xsd:string"))
				{	soap_flag_respCodeMemo1--;
					continue;
				}
			if (soap_flag_expandAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", &(a->ns1__SnapQRCodePrePayURLQueryResp::expandAttribute), "ns1:ArrayOfString"))
				{	soap_flag_expandAttribute1--;
					continue;
				}
			if (soap_flag_orderNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:orderNo", &(a->ns1__SnapQRCodePrePayURLQueryResp::orderNo), "xsd:string"))
				{	soap_flag_orderNo1--;
					continue;
				}
			if (soap_flag_deviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:deviceId", &(a->ns1__SnapQRCodePrePayURLQueryResp::deviceId), "xsd:string"))
				{	soap_flag_deviceId1--;
					continue;
				}
			if (soap_flag_qrCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:qrCode", &(a->ns1__SnapQRCodePrePayURLQueryResp::qrCode), "xsd:string"))
				{	soap_flag_qrCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SnapQRCodePrePayURLQueryResp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp, 0, sizeof(ns1__SnapQRCodePrePayURLQueryResp), 0, soap_copy_ns1__SnapQRCodePrePayURLQueryResp);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SnapQRCodePrePayURLQueryResp::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp);
	if (this->soap_out(soap, tag?tag:"ns1:SnapQRCodePrePayURLQueryResp", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SnapQRCodePrePayURLQueryResp::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SnapQRCodePrePayURLQueryResp(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SnapQRCodePrePayURLQueryResp * SOAP_FMAC4 soap_get_ns1__SnapQRCodePrePayURLQueryResp(struct soap *soap, ns1__SnapQRCodePrePayURLQueryResp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SnapQRCodePrePayURLQueryResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SnapQRCodePrePayURLQueryResp * SOAP_FMAC2 soap_instantiate_ns1__SnapQRCodePrePayURLQueryResp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SnapQRCodePrePayURLQueryResp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePrePayURLQueryResp);
		if (size)
			*size = sizeof(ns1__SnapQRCodePrePayURLQueryResp);
		((ns1__SnapQRCodePrePayURLQueryResp*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePrePayURLQueryResp[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SnapQRCodePrePayURLQueryResp);
		for (int i = 0; i < n; i++)
			((ns1__SnapQRCodePrePayURLQueryResp*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SnapQRCodePrePayURLQueryResp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SnapQRCodePrePayURLQueryResp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SnapQRCodePrePayURLQueryResp %p -> %p\n", q, p));
	*(ns1__SnapQRCodePrePayURLQueryResp*)p = *(ns1__SnapQRCodePrePayURLQueryResp*)q;
}

void ns1__SnapQRCodePrePayURLQueryReq::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__SnapQRCodePrePayURLQueryReq::reqSysDate);
	soap_default_string(soap, &this->ns1__SnapQRCodePrePayURLQueryReq::operationCode);
	soap_default_string(soap, &this->ns1__SnapQRCodePrePayURLQueryReq::cityCode);
	soap_default_string(soap, &this->ns1__SnapQRCodePrePayURLQueryReq::deviceId);
	soap_default_string(soap, &this->ns1__SnapQRCodePrePayURLQueryReq::channelType);
	this->ns1__SnapQRCodePrePayURLQueryReq::expandAttribute = NULL;
	soap_default_string(soap, &this->ns1__SnapQRCodePrePayURLQueryReq::orderNo);
	/* transient soap skipped */
}

void ns1__SnapQRCodePrePayURLQueryReq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__SnapQRCodePrePayURLQueryReq::reqSysDate);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePrePayURLQueryReq::operationCode);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePrePayURLQueryReq::cityCode);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePrePayURLQueryReq::deviceId);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePrePayURLQueryReq::channelType);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__SnapQRCodePrePayURLQueryReq::expandAttribute);
	soap_serialize_string(soap, &this->ns1__SnapQRCodePrePayURLQueryReq::orderNo);
	/* transient soap skipped */
}

int ns1__SnapQRCodePrePayURLQueryReq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SnapQRCodePrePayURLQueryReq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SnapQRCodePrePayURLQueryReq(struct soap *soap, const char *tag, int id, const ns1__SnapQRCodePrePayURLQueryReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq), "ns1:SnapQRCodePrePayURLQueryReq"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:reqSysDate", -1, &(a->ns1__SnapQRCodePrePayURLQueryReq::reqSysDate), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:operationCode", -1, &(a->ns1__SnapQRCodePrePayURLQueryReq::operationCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:cityCode", -1, &(a->ns1__SnapQRCodePrePayURLQueryReq::cityCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:deviceId", -1, &(a->ns1__SnapQRCodePrePayURLQueryReq::deviceId), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:channelType", -1, &(a->ns1__SnapQRCodePrePayURLQueryReq::channelType), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", -1, &(a->ns1__SnapQRCodePrePayURLQueryReq::expandAttribute), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:orderNo", -1, &(a->ns1__SnapQRCodePrePayURLQueryReq::orderNo), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SnapQRCodePrePayURLQueryReq::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SnapQRCodePrePayURLQueryReq(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SnapQRCodePrePayURLQueryReq * SOAP_FMAC4 soap_in_ns1__SnapQRCodePrePayURLQueryReq(struct soap *soap, const char *tag, ns1__SnapQRCodePrePayURLQueryReq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SnapQRCodePrePayURLQueryReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq, sizeof(ns1__SnapQRCodePrePayURLQueryReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SnapQRCodePrePayURLQueryReq *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_reqSysDate1 = 1;
	size_t soap_flag_operationCode1 = 1;
	size_t soap_flag_cityCode1 = 1;
	size_t soap_flag_deviceId1 = 1;
	size_t soap_flag_channelType1 = 1;
	size_t soap_flag_expandAttribute1 = 1;
	size_t soap_flag_orderNo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_reqSysDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:reqSysDate", &(a->ns1__SnapQRCodePrePayURLQueryReq::reqSysDate), "xsd:string"))
				{	soap_flag_reqSysDate1--;
					continue;
				}
			if (soap_flag_operationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operationCode", &(a->ns1__SnapQRCodePrePayURLQueryReq::operationCode), "xsd:string"))
				{	soap_flag_operationCode1--;
					continue;
				}
			if (soap_flag_cityCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cityCode", &(a->ns1__SnapQRCodePrePayURLQueryReq::cityCode), "xsd:string"))
				{	soap_flag_cityCode1--;
					continue;
				}
			if (soap_flag_deviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:deviceId", &(a->ns1__SnapQRCodePrePayURLQueryReq::deviceId), "xsd:string"))
				{	soap_flag_deviceId1--;
					continue;
				}
			if (soap_flag_channelType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:channelType", &(a->ns1__SnapQRCodePrePayURLQueryReq::channelType), "xsd:string"))
				{	soap_flag_channelType1--;
					continue;
				}
			if (soap_flag_expandAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", &(a->ns1__SnapQRCodePrePayURLQueryReq::expandAttribute), "ns1:ArrayOfString"))
				{	soap_flag_expandAttribute1--;
					continue;
				}
			if (soap_flag_orderNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:orderNo", &(a->ns1__SnapQRCodePrePayURLQueryReq::orderNo), "xsd:string"))
				{	soap_flag_orderNo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SnapQRCodePrePayURLQueryReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq, 0, sizeof(ns1__SnapQRCodePrePayURLQueryReq), 0, soap_copy_ns1__SnapQRCodePrePayURLQueryReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SnapQRCodePrePayURLQueryReq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq);
	if (this->soap_out(soap, tag?tag:"ns1:SnapQRCodePrePayURLQueryReq", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SnapQRCodePrePayURLQueryReq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SnapQRCodePrePayURLQueryReq(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SnapQRCodePrePayURLQueryReq * SOAP_FMAC4 soap_get_ns1__SnapQRCodePrePayURLQueryReq(struct soap *soap, ns1__SnapQRCodePrePayURLQueryReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SnapQRCodePrePayURLQueryReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SnapQRCodePrePayURLQueryReq * SOAP_FMAC2 soap_instantiate_ns1__SnapQRCodePrePayURLQueryReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SnapQRCodePrePayURLQueryReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePrePayURLQueryReq);
		if (size)
			*size = sizeof(ns1__SnapQRCodePrePayURLQueryReq);
		((ns1__SnapQRCodePrePayURLQueryReq*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePrePayURLQueryReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SnapQRCodePrePayURLQueryReq);
		for (int i = 0; i < n; i++)
			((ns1__SnapQRCodePrePayURLQueryReq*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SnapQRCodePrePayURLQueryReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SnapQRCodePrePayURLQueryReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SnapQRCodePrePayURLQueryReq %p -> %p\n", q, p));
	*(ns1__SnapQRCodePrePayURLQueryReq*)p = *(ns1__SnapQRCodePrePayURLQueryReq*)q;
}

void ns1__HeartBeatResp::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__HeartBeatResp::respCode);
	soap_default_string(soap, &this->ns1__HeartBeatResp::respCodeMemo);
	this->ns1__HeartBeatResp::expandAttribute = NULL;
	/* transient soap skipped */
}

void ns1__HeartBeatResp::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__HeartBeatResp::respCode);
	soap_serialize_string(soap, &this->ns1__HeartBeatResp::respCodeMemo);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__HeartBeatResp::expandAttribute);
	/* transient soap skipped */
}

int ns1__HeartBeatResp::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HeartBeatResp(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HeartBeatResp(struct soap *soap, const char *tag, int id, const ns1__HeartBeatResp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HeartBeatResp), "ns1:HeartBeatResp"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:respCode", -1, &(a->ns1__HeartBeatResp::respCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:respCodeMemo", -1, &(a->ns1__HeartBeatResp::respCodeMemo), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", -1, &(a->ns1__HeartBeatResp::expandAttribute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__HeartBeatResp::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HeartBeatResp(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HeartBeatResp * SOAP_FMAC4 soap_in_ns1__HeartBeatResp(struct soap *soap, const char *tag, ns1__HeartBeatResp *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HeartBeatResp *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HeartBeatResp, sizeof(ns1__HeartBeatResp), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HeartBeatResp)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HeartBeatResp *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_respCode1 = 1;
	size_t soap_flag_respCodeMemo1 = 1;
	size_t soap_flag_expandAttribute1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_respCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:respCode", &(a->ns1__HeartBeatResp::respCode), "xsd:string"))
				{	soap_flag_respCode1--;
					continue;
				}
			if (soap_flag_respCodeMemo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:respCodeMemo", &(a->ns1__HeartBeatResp::respCodeMemo), "xsd:string"))
				{	soap_flag_respCodeMemo1--;
					continue;
				}
			if (soap_flag_expandAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", &(a->ns1__HeartBeatResp::expandAttribute), "ns1:ArrayOfString"))
				{	soap_flag_expandAttribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HeartBeatResp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HeartBeatResp, 0, sizeof(ns1__HeartBeatResp), 0, soap_copy_ns1__HeartBeatResp);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__HeartBeatResp::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HeartBeatResp);
	if (this->soap_out(soap, tag?tag:"ns1:HeartBeatResp", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__HeartBeatResp::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HeartBeatResp(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HeartBeatResp * SOAP_FMAC4 soap_get_ns1__HeartBeatResp(struct soap *soap, ns1__HeartBeatResp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HeartBeatResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__HeartBeatResp * SOAP_FMAC2 soap_instantiate_ns1__HeartBeatResp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HeartBeatResp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HeartBeatResp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__HeartBeatResp);
		if (size)
			*size = sizeof(ns1__HeartBeatResp);
		((ns1__HeartBeatResp*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__HeartBeatResp[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HeartBeatResp);
		for (int i = 0; i < n; i++)
			((ns1__HeartBeatResp*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HeartBeatResp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HeartBeatResp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HeartBeatResp %p -> %p\n", q, p));
	*(ns1__HeartBeatResp*)p = *(ns1__HeartBeatResp*)q;
}

void ns1__HeartBeatReq::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__HeartBeatReq::reqSysDate);
	soap_default_string(soap, &this->ns1__HeartBeatReq::operationCode);
	soap_default_string(soap, &this->ns1__HeartBeatReq::cityCode);
	soap_default_string(soap, &this->ns1__HeartBeatReq::deviceId);
	soap_default_string(soap, &this->ns1__HeartBeatReq::channelType);
	this->ns1__HeartBeatReq::expandAttribute = NULL;
	/* transient soap skipped */
}

void ns1__HeartBeatReq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__HeartBeatReq::reqSysDate);
	soap_serialize_string(soap, &this->ns1__HeartBeatReq::operationCode);
	soap_serialize_string(soap, &this->ns1__HeartBeatReq::cityCode);
	soap_serialize_string(soap, &this->ns1__HeartBeatReq::deviceId);
	soap_serialize_string(soap, &this->ns1__HeartBeatReq::channelType);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__HeartBeatReq::expandAttribute);
	/* transient soap skipped */
}

int ns1__HeartBeatReq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HeartBeatReq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HeartBeatReq(struct soap *soap, const char *tag, int id, const ns1__HeartBeatReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HeartBeatReq), "ns1:HeartBeatReq"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:reqSysDate", -1, &(a->ns1__HeartBeatReq::reqSysDate), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:operationCode", -1, &(a->ns1__HeartBeatReq::operationCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:cityCode", -1, &(a->ns1__HeartBeatReq::cityCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:deviceId", -1, &(a->ns1__HeartBeatReq::deviceId), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:channelType", -1, &(a->ns1__HeartBeatReq::channelType), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", -1, &(a->ns1__HeartBeatReq::expandAttribute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__HeartBeatReq::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HeartBeatReq(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HeartBeatReq * SOAP_FMAC4 soap_in_ns1__HeartBeatReq(struct soap *soap, const char *tag, ns1__HeartBeatReq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HeartBeatReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HeartBeatReq, sizeof(ns1__HeartBeatReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HeartBeatReq)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HeartBeatReq *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_reqSysDate1 = 1;
	size_t soap_flag_operationCode1 = 1;
	size_t soap_flag_cityCode1 = 1;
	size_t soap_flag_deviceId1 = 1;
	size_t soap_flag_channelType1 = 1;
	size_t soap_flag_expandAttribute1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_reqSysDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:reqSysDate", &(a->ns1__HeartBeatReq::reqSysDate), "xsd:string"))
				{	soap_flag_reqSysDate1--;
					continue;
				}
			if (soap_flag_operationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operationCode", &(a->ns1__HeartBeatReq::operationCode), "xsd:string"))
				{	soap_flag_operationCode1--;
					continue;
				}
			if (soap_flag_cityCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cityCode", &(a->ns1__HeartBeatReq::cityCode), "xsd:string"))
				{	soap_flag_cityCode1--;
					continue;
				}
			if (soap_flag_deviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:deviceId", &(a->ns1__HeartBeatReq::deviceId), "xsd:string"))
				{	soap_flag_deviceId1--;
					continue;
				}
			if (soap_flag_channelType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:channelType", &(a->ns1__HeartBeatReq::channelType), "xsd:string"))
				{	soap_flag_channelType1--;
					continue;
				}
			if (soap_flag_expandAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", &(a->ns1__HeartBeatReq::expandAttribute), "ns1:ArrayOfString"))
				{	soap_flag_expandAttribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HeartBeatReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HeartBeatReq, 0, sizeof(ns1__HeartBeatReq), 0, soap_copy_ns1__HeartBeatReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__HeartBeatReq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HeartBeatReq);
	if (this->soap_out(soap, tag?tag:"ns1:HeartBeatReq", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__HeartBeatReq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HeartBeatReq(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HeartBeatReq * SOAP_FMAC4 soap_get_ns1__HeartBeatReq(struct soap *soap, ns1__HeartBeatReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HeartBeatReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__HeartBeatReq * SOAP_FMAC2 soap_instantiate_ns1__HeartBeatReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HeartBeatReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HeartBeatReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__HeartBeatReq);
		if (size)
			*size = sizeof(ns1__HeartBeatReq);
		((ns1__HeartBeatReq*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__HeartBeatReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HeartBeatReq);
		for (int i = 0; i < n; i++)
			((ns1__HeartBeatReq*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HeartBeatReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HeartBeatReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HeartBeatReq %p -> %p\n", q, p));
	*(ns1__HeartBeatReq*)p = *(ns1__HeartBeatReq*)q;
}

void ns1__OrderExecuteFaultResp::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__OrderExecuteFaultResp::respCode);
	soap_default_string(soap, &this->ns1__OrderExecuteFaultResp::respCodeMemo);
	this->ns1__OrderExecuteFaultResp::expandAttribute = NULL;
	/* transient soap skipped */
}

void ns1__OrderExecuteFaultResp::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__OrderExecuteFaultResp::respCode);
	soap_serialize_string(soap, &this->ns1__OrderExecuteFaultResp::respCodeMemo);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__OrderExecuteFaultResp::expandAttribute);
	/* transient soap skipped */
}

int ns1__OrderExecuteFaultResp::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OrderExecuteFaultResp(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OrderExecuteFaultResp(struct soap *soap, const char *tag, int id, const ns1__OrderExecuteFaultResp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OrderExecuteFaultResp), "ns1:OrderExecuteFaultResp"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:respCode", -1, &(a->ns1__OrderExecuteFaultResp::respCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:respCodeMemo", -1, &(a->ns1__OrderExecuteFaultResp::respCodeMemo), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", -1, &(a->ns1__OrderExecuteFaultResp::expandAttribute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OrderExecuteFaultResp::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__OrderExecuteFaultResp(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OrderExecuteFaultResp * SOAP_FMAC4 soap_in_ns1__OrderExecuteFaultResp(struct soap *soap, const char *tag, ns1__OrderExecuteFaultResp *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OrderExecuteFaultResp *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OrderExecuteFaultResp, sizeof(ns1__OrderExecuteFaultResp), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__OrderExecuteFaultResp)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__OrderExecuteFaultResp *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_respCode1 = 1;
	size_t soap_flag_respCodeMemo1 = 1;
	size_t soap_flag_expandAttribute1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_respCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:respCode", &(a->ns1__OrderExecuteFaultResp::respCode), "xsd:string"))
				{	soap_flag_respCode1--;
					continue;
				}
			if (soap_flag_respCodeMemo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:respCodeMemo", &(a->ns1__OrderExecuteFaultResp::respCodeMemo), "xsd:string"))
				{	soap_flag_respCodeMemo1--;
					continue;
				}
			if (soap_flag_expandAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", &(a->ns1__OrderExecuteFaultResp::expandAttribute), "ns1:ArrayOfString"))
				{	soap_flag_expandAttribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__OrderExecuteFaultResp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OrderExecuteFaultResp, 0, sizeof(ns1__OrderExecuteFaultResp), 0, soap_copy_ns1__OrderExecuteFaultResp);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__OrderExecuteFaultResp::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__OrderExecuteFaultResp);
	if (this->soap_out(soap, tag?tag:"ns1:OrderExecuteFaultResp", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OrderExecuteFaultResp::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OrderExecuteFaultResp(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OrderExecuteFaultResp * SOAP_FMAC4 soap_get_ns1__OrderExecuteFaultResp(struct soap *soap, ns1__OrderExecuteFaultResp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OrderExecuteFaultResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__OrderExecuteFaultResp * SOAP_FMAC2 soap_instantiate_ns1__OrderExecuteFaultResp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OrderExecuteFaultResp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__OrderExecuteFaultResp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteFaultResp);
		if (size)
			*size = sizeof(ns1__OrderExecuteFaultResp);
		((ns1__OrderExecuteFaultResp*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteFaultResp[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__OrderExecuteFaultResp);
		for (int i = 0; i < n; i++)
			((ns1__OrderExecuteFaultResp*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__OrderExecuteFaultResp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__OrderExecuteFaultResp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__OrderExecuteFaultResp %p -> %p\n", q, p));
	*(ns1__OrderExecuteFaultResp*)p = *(ns1__OrderExecuteFaultResp*)q;
}

void ns1__OrderExecuteFaultReq::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__OrderExecuteFaultReq::reqSysDate);
	soap_default_string(soap, &this->ns1__OrderExecuteFaultReq::operationCode);
	soap_default_string(soap, &this->ns1__OrderExecuteFaultReq::cityCode);
	soap_default_string(soap, &this->ns1__OrderExecuteFaultReq::deviceId);
	soap_default_string(soap, &this->ns1__OrderExecuteFaultReq::channelType);
	this->ns1__OrderExecuteFaultReq::expandAttribute = NULL;
	soap_default_string(soap, &this->ns1__OrderExecuteFaultReq::orderNo);
	soap_default_int(soap, &this->ns1__OrderExecuteFaultReq::takeSingleTicketNum);
	soap_default_string(soap, &this->ns1__OrderExecuteFaultReq::faultOccurDate);
	soap_default_string(soap, &this->ns1__OrderExecuteFaultReq::faultSlipSeq);
	soap_default_string(soap, &this->ns1__OrderExecuteFaultReq::erroCode);
	soap_default_string(soap, &this->ns1__OrderExecuteFaultReq::errorMessage);
	/* transient soap skipped */
}

void ns1__OrderExecuteFaultReq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__OrderExecuteFaultReq::reqSysDate);
	soap_serialize_string(soap, &this->ns1__OrderExecuteFaultReq::operationCode);
	soap_serialize_string(soap, &this->ns1__OrderExecuteFaultReq::cityCode);
	soap_serialize_string(soap, &this->ns1__OrderExecuteFaultReq::deviceId);
	soap_serialize_string(soap, &this->ns1__OrderExecuteFaultReq::channelType);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__OrderExecuteFaultReq::expandAttribute);
	soap_serialize_string(soap, &this->ns1__OrderExecuteFaultReq::orderNo);
	soap_serialize_string(soap, &this->ns1__OrderExecuteFaultReq::faultOccurDate);
	soap_serialize_string(soap, &this->ns1__OrderExecuteFaultReq::faultSlipSeq);
	soap_serialize_string(soap, &this->ns1__OrderExecuteFaultReq::erroCode);
	soap_serialize_string(soap, &this->ns1__OrderExecuteFaultReq::errorMessage);
	/* transient soap skipped */
}

int ns1__OrderExecuteFaultReq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OrderExecuteFaultReq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OrderExecuteFaultReq(struct soap *soap, const char *tag, int id, const ns1__OrderExecuteFaultReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OrderExecuteFaultReq), "ns1:OrderExecuteFaultReq"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:reqSysDate", -1, &(a->ns1__OrderExecuteFaultReq::reqSysDate), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:operationCode", -1, &(a->ns1__OrderExecuteFaultReq::operationCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:cityCode", -1, &(a->ns1__OrderExecuteFaultReq::cityCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:deviceId", -1, &(a->ns1__OrderExecuteFaultReq::deviceId), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:channelType", -1, &(a->ns1__OrderExecuteFaultReq::channelType), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", -1, &(a->ns1__OrderExecuteFaultReq::expandAttribute), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:orderNo", -1, &(a->ns1__OrderExecuteFaultReq::orderNo), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:takeSingleTicketNum", -1, &(a->ns1__OrderExecuteFaultReq::takeSingleTicketNum), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:faultOccurDate", -1, &(a->ns1__OrderExecuteFaultReq::faultOccurDate), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:faultSlipSeq", -1, &(a->ns1__OrderExecuteFaultReq::faultSlipSeq), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:erroCode", -1, &(a->ns1__OrderExecuteFaultReq::erroCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:errorMessage", -1, &(a->ns1__OrderExecuteFaultReq::errorMessage), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OrderExecuteFaultReq::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__OrderExecuteFaultReq(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OrderExecuteFaultReq * SOAP_FMAC4 soap_in_ns1__OrderExecuteFaultReq(struct soap *soap, const char *tag, ns1__OrderExecuteFaultReq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OrderExecuteFaultReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OrderExecuteFaultReq, sizeof(ns1__OrderExecuteFaultReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__OrderExecuteFaultReq)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__OrderExecuteFaultReq *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_reqSysDate1 = 1;
	size_t soap_flag_operationCode1 = 1;
	size_t soap_flag_cityCode1 = 1;
	size_t soap_flag_deviceId1 = 1;
	size_t soap_flag_channelType1 = 1;
	size_t soap_flag_expandAttribute1 = 1;
	size_t soap_flag_orderNo1 = 1;
	size_t soap_flag_takeSingleTicketNum1 = 1;
	size_t soap_flag_faultOccurDate1 = 1;
	size_t soap_flag_faultSlipSeq1 = 1;
	size_t soap_flag_erroCode1 = 1;
	size_t soap_flag_errorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_reqSysDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:reqSysDate", &(a->ns1__OrderExecuteFaultReq::reqSysDate), "xsd:string"))
				{	soap_flag_reqSysDate1--;
					continue;
				}
			if (soap_flag_operationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operationCode", &(a->ns1__OrderExecuteFaultReq::operationCode), "xsd:string"))
				{	soap_flag_operationCode1--;
					continue;
				}
			if (soap_flag_cityCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cityCode", &(a->ns1__OrderExecuteFaultReq::cityCode), "xsd:string"))
				{	soap_flag_cityCode1--;
					continue;
				}
			if (soap_flag_deviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:deviceId", &(a->ns1__OrderExecuteFaultReq::deviceId), "xsd:string"))
				{	soap_flag_deviceId1--;
					continue;
				}
			if (soap_flag_channelType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:channelType", &(a->ns1__OrderExecuteFaultReq::channelType), "xsd:string"))
				{	soap_flag_channelType1--;
					continue;
				}
			if (soap_flag_expandAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", &(a->ns1__OrderExecuteFaultReq::expandAttribute), "ns1:ArrayOfString"))
				{	soap_flag_expandAttribute1--;
					continue;
				}
			if (soap_flag_orderNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:orderNo", &(a->ns1__OrderExecuteFaultReq::orderNo), "xsd:string"))
				{	soap_flag_orderNo1--;
					continue;
				}
			if (soap_flag_takeSingleTicketNum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:takeSingleTicketNum", &(a->ns1__OrderExecuteFaultReq::takeSingleTicketNum), "xsd:int"))
				{	soap_flag_takeSingleTicketNum1--;
					continue;
				}
			if (soap_flag_faultOccurDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:faultOccurDate", &(a->ns1__OrderExecuteFaultReq::faultOccurDate), "xsd:string"))
				{	soap_flag_faultOccurDate1--;
					continue;
				}
			if (soap_flag_faultSlipSeq1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:faultSlipSeq", &(a->ns1__OrderExecuteFaultReq::faultSlipSeq), "xsd:string"))
				{	soap_flag_faultSlipSeq1--;
					continue;
				}
			if (soap_flag_erroCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:erroCode", &(a->ns1__OrderExecuteFaultReq::erroCode), "xsd:string"))
				{	soap_flag_erroCode1--;
					continue;
				}
			if (soap_flag_errorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:errorMessage", &(a->ns1__OrderExecuteFaultReq::errorMessage), "xsd:string"))
				{	soap_flag_errorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__OrderExecuteFaultReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OrderExecuteFaultReq, 0, sizeof(ns1__OrderExecuteFaultReq), 0, soap_copy_ns1__OrderExecuteFaultReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_takeSingleTicketNum1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__OrderExecuteFaultReq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__OrderExecuteFaultReq);
	if (this->soap_out(soap, tag?tag:"ns1:OrderExecuteFaultReq", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OrderExecuteFaultReq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OrderExecuteFaultReq(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OrderExecuteFaultReq * SOAP_FMAC4 soap_get_ns1__OrderExecuteFaultReq(struct soap *soap, ns1__OrderExecuteFaultReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OrderExecuteFaultReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__OrderExecuteFaultReq * SOAP_FMAC2 soap_instantiate_ns1__OrderExecuteFaultReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OrderExecuteFaultReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__OrderExecuteFaultReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteFaultReq);
		if (size)
			*size = sizeof(ns1__OrderExecuteFaultReq);
		((ns1__OrderExecuteFaultReq*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteFaultReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__OrderExecuteFaultReq);
		for (int i = 0; i < n; i++)
			((ns1__OrderExecuteFaultReq*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__OrderExecuteFaultReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__OrderExecuteFaultReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__OrderExecuteFaultReq %p -> %p\n", q, p));
	*(ns1__OrderExecuteFaultReq*)p = *(ns1__OrderExecuteFaultReq*)q;
}

void ns1__OrderExecuteResultResp::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__OrderExecuteResultResp::respCode);
	soap_default_string(soap, &this->ns1__OrderExecuteResultResp::respCodeMemo);
	this->ns1__OrderExecuteResultResp::expandAttribute = NULL;
	/* transient soap skipped */
}

void ns1__OrderExecuteResultResp::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__OrderExecuteResultResp::respCode);
	soap_serialize_string(soap, &this->ns1__OrderExecuteResultResp::respCodeMemo);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__OrderExecuteResultResp::expandAttribute);
	/* transient soap skipped */
}

int ns1__OrderExecuteResultResp::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OrderExecuteResultResp(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OrderExecuteResultResp(struct soap *soap, const char *tag, int id, const ns1__OrderExecuteResultResp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OrderExecuteResultResp), "ns1:OrderExecuteResultResp"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:respCode", -1, &(a->ns1__OrderExecuteResultResp::respCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:respCodeMemo", -1, &(a->ns1__OrderExecuteResultResp::respCodeMemo), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", -1, &(a->ns1__OrderExecuteResultResp::expandAttribute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OrderExecuteResultResp::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__OrderExecuteResultResp(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OrderExecuteResultResp * SOAP_FMAC4 soap_in_ns1__OrderExecuteResultResp(struct soap *soap, const char *tag, ns1__OrderExecuteResultResp *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OrderExecuteResultResp *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OrderExecuteResultResp, sizeof(ns1__OrderExecuteResultResp), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__OrderExecuteResultResp)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__OrderExecuteResultResp *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_respCode1 = 1;
	size_t soap_flag_respCodeMemo1 = 1;
	size_t soap_flag_expandAttribute1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_respCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:respCode", &(a->ns1__OrderExecuteResultResp::respCode), "xsd:string"))
				{	soap_flag_respCode1--;
					continue;
				}
			if (soap_flag_respCodeMemo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:respCodeMemo", &(a->ns1__OrderExecuteResultResp::respCodeMemo), "xsd:string"))
				{	soap_flag_respCodeMemo1--;
					continue;
				}
			if (soap_flag_expandAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", &(a->ns1__OrderExecuteResultResp::expandAttribute), "ns1:ArrayOfString"))
				{	soap_flag_expandAttribute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__OrderExecuteResultResp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OrderExecuteResultResp, 0, sizeof(ns1__OrderExecuteResultResp), 0, soap_copy_ns1__OrderExecuteResultResp);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__OrderExecuteResultResp::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__OrderExecuteResultResp);
	if (this->soap_out(soap, tag?tag:"ns1:OrderExecuteResultResp", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OrderExecuteResultResp::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OrderExecuteResultResp(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OrderExecuteResultResp * SOAP_FMAC4 soap_get_ns1__OrderExecuteResultResp(struct soap *soap, ns1__OrderExecuteResultResp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OrderExecuteResultResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__OrderExecuteResultResp * SOAP_FMAC2 soap_instantiate_ns1__OrderExecuteResultResp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OrderExecuteResultResp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__OrderExecuteResultResp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteResultResp);
		if (size)
			*size = sizeof(ns1__OrderExecuteResultResp);
		((ns1__OrderExecuteResultResp*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteResultResp[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__OrderExecuteResultResp);
		for (int i = 0; i < n; i++)
			((ns1__OrderExecuteResultResp*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__OrderExecuteResultResp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__OrderExecuteResultResp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__OrderExecuteResultResp %p -> %p\n", q, p));
	*(ns1__OrderExecuteResultResp*)p = *(ns1__OrderExecuteResultResp*)q;
}

void ns1__OrderExecuteResultReq::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__OrderExecuteResultReq::reqSysDate);
	soap_default_string(soap, &this->ns1__OrderExecuteResultReq::operationCode);
	soap_default_string(soap, &this->ns1__OrderExecuteResultReq::cityCode);
	soap_default_string(soap, &this->ns1__OrderExecuteResultReq::deviceId);
	soap_default_string(soap, &this->ns1__OrderExecuteResultReq::channelType);
	this->ns1__OrderExecuteResultReq::expandAttribute = NULL;
	soap_default_string(soap, &this->ns1__OrderExecuteResultReq::orderNo);
	soap_default_int(soap, &this->ns1__OrderExecuteResultReq::takeSingleTicketNum);
	soap_default_string(soap, &this->ns1__OrderExecuteResultReq::takeSingleTicketDate);
	/* transient soap skipped */
}

void ns1__OrderExecuteResultReq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__OrderExecuteResultReq::reqSysDate);
	soap_serialize_string(soap, &this->ns1__OrderExecuteResultReq::operationCode);
	soap_serialize_string(soap, &this->ns1__OrderExecuteResultReq::cityCode);
	soap_serialize_string(soap, &this->ns1__OrderExecuteResultReq::deviceId);
	soap_serialize_string(soap, &this->ns1__OrderExecuteResultReq::channelType);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__OrderExecuteResultReq::expandAttribute);
	soap_serialize_string(soap, &this->ns1__OrderExecuteResultReq::orderNo);
	soap_serialize_string(soap, &this->ns1__OrderExecuteResultReq::takeSingleTicketDate);
	/* transient soap skipped */
}

int ns1__OrderExecuteResultReq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OrderExecuteResultReq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OrderExecuteResultReq(struct soap *soap, const char *tag, int id, const ns1__OrderExecuteResultReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OrderExecuteResultReq), "ns1:OrderExecuteResultReq"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:reqSysDate", -1, &(a->ns1__OrderExecuteResultReq::reqSysDate), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:operationCode", -1, &(a->ns1__OrderExecuteResultReq::operationCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:cityCode", -1, &(a->ns1__OrderExecuteResultReq::cityCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:deviceId", -1, &(a->ns1__OrderExecuteResultReq::deviceId), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:channelType", -1, &(a->ns1__OrderExecuteResultReq::channelType), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", -1, &(a->ns1__OrderExecuteResultReq::expandAttribute), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:orderNo", -1, &(a->ns1__OrderExecuteResultReq::orderNo), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:takeSingleTicketNum", -1, &(a->ns1__OrderExecuteResultReq::takeSingleTicketNum), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:takeSingleTicketDate", -1, &(a->ns1__OrderExecuteResultReq::takeSingleTicketDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OrderExecuteResultReq::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__OrderExecuteResultReq(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OrderExecuteResultReq * SOAP_FMAC4 soap_in_ns1__OrderExecuteResultReq(struct soap *soap, const char *tag, ns1__OrderExecuteResultReq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OrderExecuteResultReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OrderExecuteResultReq, sizeof(ns1__OrderExecuteResultReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__OrderExecuteResultReq)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__OrderExecuteResultReq *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_reqSysDate1 = 1;
	size_t soap_flag_operationCode1 = 1;
	size_t soap_flag_cityCode1 = 1;
	size_t soap_flag_deviceId1 = 1;
	size_t soap_flag_channelType1 = 1;
	size_t soap_flag_expandAttribute1 = 1;
	size_t soap_flag_orderNo1 = 1;
	size_t soap_flag_takeSingleTicketNum1 = 1;
	size_t soap_flag_takeSingleTicketDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_reqSysDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:reqSysDate", &(a->ns1__OrderExecuteResultReq::reqSysDate), "xsd:string"))
				{	soap_flag_reqSysDate1--;
					continue;
				}
			if (soap_flag_operationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operationCode", &(a->ns1__OrderExecuteResultReq::operationCode), "xsd:string"))
				{	soap_flag_operationCode1--;
					continue;
				}
			if (soap_flag_cityCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cityCode", &(a->ns1__OrderExecuteResultReq::cityCode), "xsd:string"))
				{	soap_flag_cityCode1--;
					continue;
				}
			if (soap_flag_deviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:deviceId", &(a->ns1__OrderExecuteResultReq::deviceId), "xsd:string"))
				{	soap_flag_deviceId1--;
					continue;
				}
			if (soap_flag_channelType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:channelType", &(a->ns1__OrderExecuteResultReq::channelType), "xsd:string"))
				{	soap_flag_channelType1--;
					continue;
				}
			if (soap_flag_expandAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", &(a->ns1__OrderExecuteResultReq::expandAttribute), "ns1:ArrayOfString"))
				{	soap_flag_expandAttribute1--;
					continue;
				}
			if (soap_flag_orderNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:orderNo", &(a->ns1__OrderExecuteResultReq::orderNo), "xsd:string"))
				{	soap_flag_orderNo1--;
					continue;
				}
			if (soap_flag_takeSingleTicketNum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:takeSingleTicketNum", &(a->ns1__OrderExecuteResultReq::takeSingleTicketNum), "xsd:int"))
				{	soap_flag_takeSingleTicketNum1--;
					continue;
				}
			if (soap_flag_takeSingleTicketDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:takeSingleTicketDate", &(a->ns1__OrderExecuteResultReq::takeSingleTicketDate), "xsd:string"))
				{	soap_flag_takeSingleTicketDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__OrderExecuteResultReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OrderExecuteResultReq, 0, sizeof(ns1__OrderExecuteResultReq), 0, soap_copy_ns1__OrderExecuteResultReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_takeSingleTicketNum1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__OrderExecuteResultReq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__OrderExecuteResultReq);
	if (this->soap_out(soap, tag?tag:"ns1:OrderExecuteResultReq", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OrderExecuteResultReq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OrderExecuteResultReq(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OrderExecuteResultReq * SOAP_FMAC4 soap_get_ns1__OrderExecuteResultReq(struct soap *soap, ns1__OrderExecuteResultReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OrderExecuteResultReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__OrderExecuteResultReq * SOAP_FMAC2 soap_instantiate_ns1__OrderExecuteResultReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OrderExecuteResultReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__OrderExecuteResultReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteResultReq);
		if (size)
			*size = sizeof(ns1__OrderExecuteResultReq);
		((ns1__OrderExecuteResultReq*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteResultReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__OrderExecuteResultReq);
		for (int i = 0; i < n; i++)
			((ns1__OrderExecuteResultReq*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__OrderExecuteResultReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__OrderExecuteResultReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__OrderExecuteResultReq %p -> %p\n", q, p));
	*(ns1__OrderExecuteResultReq*)p = *(ns1__OrderExecuteResultReq*)q;
}

void ns1__Responce::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__Responce::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__Responce::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Responce(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Responce(struct soap *soap, const char *tag, int id, const ns1__Responce *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Responce), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Responce::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Responce(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Responce * SOAP_FMAC4 soap_in_ns1__Responce(struct soap *soap, const char *tag, ns1__Responce *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Responce *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Responce, sizeof(ns1__Responce), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Responce)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Responce *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Responce *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Responce, 0, sizeof(ns1__Responce), 0, soap_copy_ns1__Responce);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Responce::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Responce);
	if (this->soap_out(soap, tag?tag:"ns1:Responce", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Responce::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Responce(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Responce * SOAP_FMAC4 soap_get_ns1__Responce(struct soap *soap, ns1__Responce *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Responce(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Responce * SOAP_FMAC2 soap_instantiate_ns1__Responce(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Responce(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Responce, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:OrderCommitResp"))
	{	cp->type = SOAP_TYPE_ns1__OrderCommitResp;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__OrderCommitResp);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__OrderCommitResp);
			((ns1__OrderCommitResp*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__OrderCommitResp[n]);
			if (size)
				*size = n * sizeof(ns1__OrderCommitResp);
			for (int i = 0; i < n; i++)
				((ns1__OrderCommitResp*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__OrderCommitResp*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:OrderExecuteResultResp"))
	{	cp->type = SOAP_TYPE_ns1__OrderExecuteResultResp;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteResultResp);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__OrderExecuteResultResp);
			((ns1__OrderExecuteResultResp*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteResultResp[n]);
			if (size)
				*size = n * sizeof(ns1__OrderExecuteResultResp);
			for (int i = 0; i < n; i++)
				((ns1__OrderExecuteResultResp*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__OrderExecuteResultResp*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:OrderExecuteFaultResp"))
	{	cp->type = SOAP_TYPE_ns1__OrderExecuteFaultResp;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteFaultResp);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__OrderExecuteFaultResp);
			((ns1__OrderExecuteFaultResp*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteFaultResp[n]);
			if (size)
				*size = n * sizeof(ns1__OrderExecuteFaultResp);
			for (int i = 0; i < n; i++)
				((ns1__OrderExecuteFaultResp*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__OrderExecuteFaultResp*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:HeartBeatResp"))
	{	cp->type = SOAP_TYPE_ns1__HeartBeatResp;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__HeartBeatResp);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__HeartBeatResp);
			((ns1__HeartBeatResp*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__HeartBeatResp[n]);
			if (size)
				*size = n * sizeof(ns1__HeartBeatResp);
			for (int i = 0; i < n; i++)
				((ns1__HeartBeatResp*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__HeartBeatResp*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SnapQRCodePrePayURLQueryResp"))
	{	cp->type = SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePrePayURLQueryResp);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SnapQRCodePrePayURLQueryResp);
			((ns1__SnapQRCodePrePayURLQueryResp*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePrePayURLQueryResp[n]);
			if (size)
				*size = n * sizeof(ns1__SnapQRCodePrePayURLQueryResp);
			for (int i = 0; i < n; i++)
				((ns1__SnapQRCodePrePayURLQueryResp*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SnapQRCodePrePayURLQueryResp*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SnapQRCodePayResultQueryResp"))
	{	cp->type = SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePayResultQueryResp);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SnapQRCodePayResultQueryResp);
			((ns1__SnapQRCodePayResultQueryResp*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePayResultQueryResp[n]);
			if (size)
				*size = n * sizeof(ns1__SnapQRCodePayResultQueryResp);
			for (int i = 0; i < n; i++)
				((ns1__SnapQRCodePayResultQueryResp*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SnapQRCodePayResultQueryResp*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SnapQRCodeTakeOrderQueryResp"))
	{	cp->type = SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodeTakeOrderQueryResp);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SnapQRCodeTakeOrderQueryResp);
			((ns1__SnapQRCodeTakeOrderQueryResp*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodeTakeOrderQueryResp[n]);
			if (size)
				*size = n * sizeof(ns1__SnapQRCodeTakeOrderQueryResp);
			for (int i = 0; i < n; i++)
				((ns1__SnapQRCodeTakeOrderQueryResp*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SnapQRCodeTakeOrderQueryResp*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Responce);
		if (size)
			*size = sizeof(ns1__Responce);
		((ns1__Responce*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Responce[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Responce);
		for (int i = 0; i < n; i++)
			((ns1__Responce*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Responce*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Responce(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Responce %p -> %p\n", q, p));
	*(ns1__Responce*)p = *(ns1__Responce*)q;
}

void ns1__OrderCommitResp::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__OrderCommitResp::respCode);
	soap_default_string(soap, &this->ns1__OrderCommitResp::respCodeMemo);
	this->ns1__OrderCommitResp::expandAttribute = NULL;
	soap_default_string(soap, &this->ns1__OrderCommitResp::partnerNo);
	soap_default_string(soap, &this->ns1__OrderCommitResp::orderNo);
	soap_default_string(soap, &this->ns1__OrderCommitResp::subject);
	soap_default_string(soap, &this->ns1__OrderCommitResp::body);
	soap_default_string(soap, &this->ns1__OrderCommitResp::payType);
	soap_default_string(soap, &this->ns1__OrderCommitResp::amount);
	soap_default_string(soap, &this->ns1__OrderCommitResp::account);
	soap_default_string(soap, &this->ns1__OrderCommitResp::notifyUrl);
	soap_default_string(soap, &this->ns1__OrderCommitResp::merchantCert);
	soap_default_int(soap, &this->ns1__OrderCommitResp::timeout);
	/* transient soap skipped */
}

void ns1__OrderCommitResp::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__OrderCommitResp::respCode);
	soap_serialize_string(soap, &this->ns1__OrderCommitResp::respCodeMemo);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__OrderCommitResp::expandAttribute);
	soap_serialize_string(soap, &this->ns1__OrderCommitResp::partnerNo);
	soap_serialize_string(soap, &this->ns1__OrderCommitResp::orderNo);
	soap_serialize_string(soap, &this->ns1__OrderCommitResp::subject);
	soap_serialize_string(soap, &this->ns1__OrderCommitResp::body);
	soap_serialize_string(soap, &this->ns1__OrderCommitResp::payType);
	soap_serialize_string(soap, &this->ns1__OrderCommitResp::amount);
	soap_serialize_string(soap, &this->ns1__OrderCommitResp::account);
	soap_serialize_string(soap, &this->ns1__OrderCommitResp::notifyUrl);
	soap_serialize_string(soap, &this->ns1__OrderCommitResp::merchantCert);
	/* transient soap skipped */
}

int ns1__OrderCommitResp::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OrderCommitResp(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OrderCommitResp(struct soap *soap, const char *tag, int id, const ns1__OrderCommitResp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OrderCommitResp), "ns1:OrderCommitResp"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:respCode", -1, &(a->ns1__OrderCommitResp::respCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:respCodeMemo", -1, &(a->ns1__OrderCommitResp::respCodeMemo), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", -1, &(a->ns1__OrderCommitResp::expandAttribute), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:partnerNo", -1, &(a->ns1__OrderCommitResp::partnerNo), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:orderNo", -1, &(a->ns1__OrderCommitResp::orderNo), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:subject", -1, &(a->ns1__OrderCommitResp::subject), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:body", -1, &(a->ns1__OrderCommitResp::body), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:payType", -1, &(a->ns1__OrderCommitResp::payType), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:amount", -1, &(a->ns1__OrderCommitResp::amount), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:account", -1, &(a->ns1__OrderCommitResp::account), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:notifyUrl", -1, &(a->ns1__OrderCommitResp::notifyUrl), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:merchantCert", -1, &(a->ns1__OrderCommitResp::merchantCert), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:timeout", -1, &(a->ns1__OrderCommitResp::timeout), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OrderCommitResp::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__OrderCommitResp(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OrderCommitResp * SOAP_FMAC4 soap_in_ns1__OrderCommitResp(struct soap *soap, const char *tag, ns1__OrderCommitResp *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OrderCommitResp *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OrderCommitResp, sizeof(ns1__OrderCommitResp), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__OrderCommitResp)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__OrderCommitResp *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_respCode1 = 1;
	size_t soap_flag_respCodeMemo1 = 1;
	size_t soap_flag_expandAttribute1 = 1;
	size_t soap_flag_partnerNo1 = 1;
	size_t soap_flag_orderNo1 = 1;
	size_t soap_flag_subject1 = 1;
	size_t soap_flag_body1 = 1;
	size_t soap_flag_payType1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_account1 = 1;
	size_t soap_flag_notifyUrl1 = 1;
	size_t soap_flag_merchantCert1 = 1;
	size_t soap_flag_timeout1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_respCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:respCode", &(a->ns1__OrderCommitResp::respCode), "xsd:string"))
				{	soap_flag_respCode1--;
					continue;
				}
			if (soap_flag_respCodeMemo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:respCodeMemo", &(a->ns1__OrderCommitResp::respCodeMemo), "xsd:string"))
				{	soap_flag_respCodeMemo1--;
					continue;
				}
			if (soap_flag_expandAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", &(a->ns1__OrderCommitResp::expandAttribute), "ns1:ArrayOfString"))
				{	soap_flag_expandAttribute1--;
					continue;
				}
			if (soap_flag_partnerNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:partnerNo", &(a->ns1__OrderCommitResp::partnerNo), "xsd:string"))
				{	soap_flag_partnerNo1--;
					continue;
				}
			if (soap_flag_orderNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:orderNo", &(a->ns1__OrderCommitResp::orderNo), "xsd:string"))
				{	soap_flag_orderNo1--;
					continue;
				}
			if (soap_flag_subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:subject", &(a->ns1__OrderCommitResp::subject), "xsd:string"))
				{	soap_flag_subject1--;
					continue;
				}
			if (soap_flag_body1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:body", &(a->ns1__OrderCommitResp::body), "xsd:string"))
				{	soap_flag_body1--;
					continue;
				}
			if (soap_flag_payType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:payType", &(a->ns1__OrderCommitResp::payType), "xsd:string"))
				{	soap_flag_payType1--;
					continue;
				}
			if (soap_flag_amount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:amount", &(a->ns1__OrderCommitResp::amount), "xsd:string"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_account1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:account", &(a->ns1__OrderCommitResp::account), "xsd:string"))
				{	soap_flag_account1--;
					continue;
				}
			if (soap_flag_notifyUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:notifyUrl", &(a->ns1__OrderCommitResp::notifyUrl), "xsd:string"))
				{	soap_flag_notifyUrl1--;
					continue;
				}
			if (soap_flag_merchantCert1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:merchantCert", &(a->ns1__OrderCommitResp::merchantCert), "xsd:string"))
				{	soap_flag_merchantCert1--;
					continue;
				}
			if (soap_flag_timeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:timeout", &(a->ns1__OrderCommitResp::timeout), "xsd:int"))
				{	soap_flag_timeout1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__OrderCommitResp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OrderCommitResp, 0, sizeof(ns1__OrderCommitResp), 0, soap_copy_ns1__OrderCommitResp);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_timeout1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__OrderCommitResp::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__OrderCommitResp);
	if (this->soap_out(soap, tag?tag:"ns1:OrderCommitResp", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OrderCommitResp::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OrderCommitResp(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OrderCommitResp * SOAP_FMAC4 soap_get_ns1__OrderCommitResp(struct soap *soap, ns1__OrderCommitResp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OrderCommitResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__OrderCommitResp * SOAP_FMAC2 soap_instantiate_ns1__OrderCommitResp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OrderCommitResp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__OrderCommitResp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__OrderCommitResp);
		if (size)
			*size = sizeof(ns1__OrderCommitResp);
		((ns1__OrderCommitResp*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__OrderCommitResp[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__OrderCommitResp);
		for (int i = 0; i < n; i++)
			((ns1__OrderCommitResp*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__OrderCommitResp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__OrderCommitResp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__OrderCommitResp %p -> %p\n", q, p));
	*(ns1__OrderCommitResp*)p = *(ns1__OrderCommitResp*)q;
}

void ns1__ArrayOfString::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfString::__sizestring = 0;
	this->ns1__ArrayOfString::string = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfString::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfString::string)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfString::__sizestring; i++)
		{
			soap_serialize_string(soap, this->ns1__ArrayOfString::string + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfString(struct soap *soap, const char *tag, int id, const ns1__ArrayOfString *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfString), type))
		return soap->error;
	if (a->ns1__ArrayOfString::string)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfString::__sizestring; i++)
			if (soap_out_string(soap, "ns1:string", -1, a->ns1__ArrayOfString::string + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfString::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfString(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_in_ns1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfString)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfString *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_string1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:string", 1, NULL))
			{	if (a->ns1__ArrayOfString::string == NULL)
				{	if (soap_blist_string1 == NULL)
						soap_blist_string1 = soap_new_block(soap);
					a->ns1__ArrayOfString::string = (char **)soap_push_block(soap, soap_blist_string1, sizeof(char *));
					if (a->ns1__ArrayOfString::string == NULL)
						return NULL;
					*a->ns1__ArrayOfString::string = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns1:string", a->ns1__ArrayOfString::string, "xsd:string"))
				{	a->ns1__ArrayOfString::__sizestring++;
					a->ns1__ArrayOfString::string = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfString::string)
			soap_pop_block(soap, soap_blist_string1);
		if (a->ns1__ArrayOfString::__sizestring)
			a->ns1__ArrayOfString::string = (char **)soap_save_block(soap, soap_blist_string1, NULL, 1);
		else
		{	a->ns1__ArrayOfString::string = NULL;
			if (soap_blist_string1)
				soap_end_block(soap, soap_blist_string1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfString, 0, sizeof(ns1__ArrayOfString), 0, soap_copy_ns1__ArrayOfString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfString);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfString", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfString(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_get_ns1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfString * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfString);
		if (size)
			*size = sizeof(ns1__ArrayOfString);
		((ns1__ArrayOfString*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfString[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfString);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfString*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfString*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfString %p -> %p\n", q, p));
	*(ns1__ArrayOfString*)p = *(ns1__ArrayOfString*)q;
}

void ns1__Request::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__Request::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__Request::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Request(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Request(struct soap *soap, const char *tag, int id, const ns1__Request *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Request), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Request::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Request(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Request * SOAP_FMAC4 soap_in_ns1__Request(struct soap *soap, const char *tag, ns1__Request *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Request, sizeof(ns1__Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Request)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Request *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Request, 0, sizeof(ns1__Request), 0, soap_copy_ns1__Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Request::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Request);
	if (this->soap_out(soap, tag?tag:"ns1:Request", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Request::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Request(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Request * SOAP_FMAC4 soap_get_ns1__Request(struct soap *soap, ns1__Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Request * SOAP_FMAC2 soap_instantiate_ns1__Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:OrderCommitReq"))
	{	cp->type = SOAP_TYPE_ns1__OrderCommitReq;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__OrderCommitReq);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__OrderCommitReq);
			((ns1__OrderCommitReq*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__OrderCommitReq[n]);
			if (size)
				*size = n * sizeof(ns1__OrderCommitReq);
			for (int i = 0; i < n; i++)
				((ns1__OrderCommitReq*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__OrderCommitReq*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:OrderExecuteResultReq"))
	{	cp->type = SOAP_TYPE_ns1__OrderExecuteResultReq;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteResultReq);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__OrderExecuteResultReq);
			((ns1__OrderExecuteResultReq*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteResultReq[n]);
			if (size)
				*size = n * sizeof(ns1__OrderExecuteResultReq);
			for (int i = 0; i < n; i++)
				((ns1__OrderExecuteResultReq*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__OrderExecuteResultReq*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:OrderExecuteFaultReq"))
	{	cp->type = SOAP_TYPE_ns1__OrderExecuteFaultReq;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteFaultReq);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__OrderExecuteFaultReq);
			((ns1__OrderExecuteFaultReq*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__OrderExecuteFaultReq[n]);
			if (size)
				*size = n * sizeof(ns1__OrderExecuteFaultReq);
			for (int i = 0; i < n; i++)
				((ns1__OrderExecuteFaultReq*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__OrderExecuteFaultReq*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:HeartBeatReq"))
	{	cp->type = SOAP_TYPE_ns1__HeartBeatReq;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__HeartBeatReq);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__HeartBeatReq);
			((ns1__HeartBeatReq*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__HeartBeatReq[n]);
			if (size)
				*size = n * sizeof(ns1__HeartBeatReq);
			for (int i = 0; i < n; i++)
				((ns1__HeartBeatReq*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__HeartBeatReq*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SnapQRCodePrePayURLQueryReq"))
	{	cp->type = SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePrePayURLQueryReq);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SnapQRCodePrePayURLQueryReq);
			((ns1__SnapQRCodePrePayURLQueryReq*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePrePayURLQueryReq[n]);
			if (size)
				*size = n * sizeof(ns1__SnapQRCodePrePayURLQueryReq);
			for (int i = 0; i < n; i++)
				((ns1__SnapQRCodePrePayURLQueryReq*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SnapQRCodePrePayURLQueryReq*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SnapQRCodePayResultQueryReq"))
	{	cp->type = SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePayResultQueryReq);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SnapQRCodePayResultQueryReq);
			((ns1__SnapQRCodePayResultQueryReq*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodePayResultQueryReq[n]);
			if (size)
				*size = n * sizeof(ns1__SnapQRCodePayResultQueryReq);
			for (int i = 0; i < n; i++)
				((ns1__SnapQRCodePayResultQueryReq*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SnapQRCodePayResultQueryReq*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SnapQRCodeTakeOrderQueryReq"))
	{	cp->type = SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodeTakeOrderQueryReq);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__SnapQRCodeTakeOrderQueryReq);
			((ns1__SnapQRCodeTakeOrderQueryReq*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__SnapQRCodeTakeOrderQueryReq[n]);
			if (size)
				*size = n * sizeof(ns1__SnapQRCodeTakeOrderQueryReq);
			for (int i = 0; i < n; i++)
				((ns1__SnapQRCodeTakeOrderQueryReq*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__SnapQRCodeTakeOrderQueryReq*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Request);
		if (size)
			*size = sizeof(ns1__Request);
		((ns1__Request*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Request[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Request);
		for (int i = 0; i < n; i++)
			((ns1__Request*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Request %p -> %p\n", q, p));
	*(ns1__Request*)p = *(ns1__Request*)q;
}

void ns1__OrderCommitReq::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__OrderCommitReq::reqSysDate);
	soap_default_string(soap, &this->ns1__OrderCommitReq::operationCode);
	soap_default_string(soap, &this->ns1__OrderCommitReq::cityCode);
	soap_default_string(soap, &this->ns1__OrderCommitReq::deviceId);
	soap_default_string(soap, &this->ns1__OrderCommitReq::channelType);
	this->ns1__OrderCommitReq::expandAttribute = NULL;
	soap_default_string(soap, &this->ns1__OrderCommitReq::paymentCode);
	soap_default_string(soap, &this->ns1__OrderCommitReq::msisdn);
	soap_default_string(soap, &this->ns1__OrderCommitReq::iccid);
	soap_default_string(soap, &this->ns1__OrderCommitReq::serviceId);
	soap_default_string(soap, &this->ns1__OrderCommitReq::paymentVendor);
	soap_default_string(soap, &this->ns1__OrderCommitReq::pickupStationCode);
	soap_default_string(soap, &this->ns1__OrderCommitReq::getOffStationCode);
	soap_default_string(soap, &this->ns1__OrderCommitReq::singleTicketPrice);
	soap_default_string(soap, &this->ns1__OrderCommitReq::singleTicketNum);
	soap_default_string(soap, &this->ns1__OrderCommitReq::singleTicketType);
	/* transient soap skipped */
}

void ns1__OrderCommitReq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::reqSysDate);
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::operationCode);
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::cityCode);
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::deviceId);
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::channelType);
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->ns1__OrderCommitReq::expandAttribute);
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::paymentCode);
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::msisdn);
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::iccid);
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::serviceId);
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::paymentVendor);
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::pickupStationCode);
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::getOffStationCode);
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::singleTicketPrice);
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::singleTicketNum);
	soap_serialize_string(soap, &this->ns1__OrderCommitReq::singleTicketType);
	/* transient soap skipped */
}

int ns1__OrderCommitReq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OrderCommitReq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OrderCommitReq(struct soap *soap, const char *tag, int id, const ns1__OrderCommitReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OrderCommitReq), "ns1:OrderCommitReq"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "ns1:reqSysDate", -1, &(a->ns1__OrderCommitReq::reqSysDate), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:operationCode", -1, &(a->ns1__OrderCommitReq::operationCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:cityCode", -1, &(a->ns1__OrderCommitReq::cityCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:deviceId", -1, &(a->ns1__OrderCommitReq::deviceId), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:channelType", -1, &(a->ns1__OrderCommitReq::channelType), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", -1, &(a->ns1__OrderCommitReq::expandAttribute), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:paymentCode", -1, &(a->ns1__OrderCommitReq::paymentCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:msisdn", -1, &(a->ns1__OrderCommitReq::msisdn), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:iccid", -1, &(a->ns1__OrderCommitReq::iccid), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:serviceId", -1, &(a->ns1__OrderCommitReq::serviceId), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:paymentVendor", -1, &(a->ns1__OrderCommitReq::paymentVendor), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:pickupStationCode", -1, &(a->ns1__OrderCommitReq::pickupStationCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:getOffStationCode", -1, &(a->ns1__OrderCommitReq::getOffStationCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:singleTicketPrice", -1, &(a->ns1__OrderCommitReq::singleTicketPrice), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:singleTicketNum", -1, &(a->ns1__OrderCommitReq::singleTicketNum), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:singleTicketType", -1, &(a->ns1__OrderCommitReq::singleTicketType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__OrderCommitReq::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__OrderCommitReq(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OrderCommitReq * SOAP_FMAC4 soap_in_ns1__OrderCommitReq(struct soap *soap, const char *tag, ns1__OrderCommitReq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OrderCommitReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OrderCommitReq, sizeof(ns1__OrderCommitReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__OrderCommitReq)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__OrderCommitReq *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_reqSysDate1 = 1;
	size_t soap_flag_operationCode1 = 1;
	size_t soap_flag_cityCode1 = 1;
	size_t soap_flag_deviceId1 = 1;
	size_t soap_flag_channelType1 = 1;
	size_t soap_flag_expandAttribute1 = 1;
	size_t soap_flag_paymentCode1 = 1;
	size_t soap_flag_msisdn1 = 1;
	size_t soap_flag_iccid1 = 1;
	size_t soap_flag_serviceId1 = 1;
	size_t soap_flag_paymentVendor1 = 1;
	size_t soap_flag_pickupStationCode1 = 1;
	size_t soap_flag_getOffStationCode1 = 1;
	size_t soap_flag_singleTicketPrice1 = 1;
	size_t soap_flag_singleTicketNum1 = 1;
	size_t soap_flag_singleTicketType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_reqSysDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:reqSysDate", &(a->ns1__OrderCommitReq::reqSysDate), "xsd:string"))
				{	soap_flag_reqSysDate1--;
					continue;
				}
			if (soap_flag_operationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:operationCode", &(a->ns1__OrderCommitReq::operationCode), "xsd:string"))
				{	soap_flag_operationCode1--;
					continue;
				}
			if (soap_flag_cityCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cityCode", &(a->ns1__OrderCommitReq::cityCode), "xsd:string"))
				{	soap_flag_cityCode1--;
					continue;
				}
			if (soap_flag_deviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:deviceId", &(a->ns1__OrderCommitReq::deviceId), "xsd:string"))
				{	soap_flag_deviceId1--;
					continue;
				}
			if (soap_flag_channelType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:channelType", &(a->ns1__OrderCommitReq::channelType), "xsd:string"))
				{	soap_flag_channelType1--;
					continue;
				}
			if (soap_flag_expandAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:expandAttribute", &(a->ns1__OrderCommitReq::expandAttribute), "ns1:ArrayOfString"))
				{	soap_flag_expandAttribute1--;
					continue;
				}
			if (soap_flag_paymentCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:paymentCode", &(a->ns1__OrderCommitReq::paymentCode), "xsd:string"))
				{	soap_flag_paymentCode1--;
					continue;
				}
			if (soap_flag_msisdn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:msisdn", &(a->ns1__OrderCommitReq::msisdn), "xsd:string"))
				{	soap_flag_msisdn1--;
					continue;
				}
			if (soap_flag_iccid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:iccid", &(a->ns1__OrderCommitReq::iccid), "xsd:string"))
				{	soap_flag_iccid1--;
					continue;
				}
			if (soap_flag_serviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:serviceId", &(a->ns1__OrderCommitReq::serviceId), "xsd:string"))
				{	soap_flag_serviceId1--;
					continue;
				}
			if (soap_flag_paymentVendor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:paymentVendor", &(a->ns1__OrderCommitReq::paymentVendor), "xsd:string"))
				{	soap_flag_paymentVendor1--;
					continue;
				}
			if (soap_flag_pickupStationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:pickupStationCode", &(a->ns1__OrderCommitReq::pickupStationCode), "xsd:string"))
				{	soap_flag_pickupStationCode1--;
					continue;
				}
			if (soap_flag_getOffStationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:getOffStationCode", &(a->ns1__OrderCommitReq::getOffStationCode), "xsd:string"))
				{	soap_flag_getOffStationCode1--;
					continue;
				}
			if (soap_flag_singleTicketPrice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:singleTicketPrice", &(a->ns1__OrderCommitReq::singleTicketPrice), "xsd:string"))
				{	soap_flag_singleTicketPrice1--;
					continue;
				}
			if (soap_flag_singleTicketNum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:singleTicketNum", &(a->ns1__OrderCommitReq::singleTicketNum), "xsd:string"))
				{	soap_flag_singleTicketNum1--;
					continue;
				}
			if (soap_flag_singleTicketType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:singleTicketType", &(a->ns1__OrderCommitReq::singleTicketType), "xsd:string"))
				{	soap_flag_singleTicketType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__OrderCommitReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OrderCommitReq, 0, sizeof(ns1__OrderCommitReq), 0, soap_copy_ns1__OrderCommitReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__OrderCommitReq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__OrderCommitReq);
	if (this->soap_out(soap, tag?tag:"ns1:OrderCommitReq", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OrderCommitReq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OrderCommitReq(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OrderCommitReq * SOAP_FMAC4 soap_get_ns1__OrderCommitReq(struct soap *soap, ns1__OrderCommitReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OrderCommitReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__OrderCommitReq * SOAP_FMAC2 soap_instantiate_ns1__OrderCommitReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OrderCommitReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__OrderCommitReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__OrderCommitReq);
		if (size)
			*size = sizeof(ns1__OrderCommitReq);
		((ns1__OrderCommitReq*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__OrderCommitReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__OrderCommitReq);
		for (int i = 0; i < n; i++)
			((ns1__OrderCommitReq*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__OrderCommitReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__OrderCommitReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__OrderCommitReq %p -> %p\n", q, p));
	*(ns1__OrderCommitReq*)p = *(ns1__OrderCommitReq*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__S1_USCORE020(struct soap *soap, struct __ns3__S1_USCORE020 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__S1_USCORE020 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__S1_USCORE020(struct soap *soap, const struct __ns3__S1_USCORE020 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__S1_USCORE020(soap, &a->ns1__S1_USCORE020);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__S1_USCORE020(struct soap *soap, const char *tag, int id, const struct __ns3__S1_USCORE020 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__S1_USCORE020(soap, "ns1:S1_020", -1, &a->ns1__S1_USCORE020, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__S1_USCORE020 * SOAP_FMAC4 soap_in___ns3__S1_USCORE020(struct soap *soap, const char *tag, struct __ns3__S1_USCORE020 *a, const char *type)
{
	size_t soap_flag_ns1__S1_USCORE020 = 1;
	short soap_flag;
	a = (struct __ns3__S1_USCORE020 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__S1_USCORE020, sizeof(struct __ns3__S1_USCORE020), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__S1_USCORE020(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__S1_USCORE020 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__S1_USCORE020(soap, "ns1:S1_020", &a->ns1__S1_USCORE020, ""))
				{	soap_flag_ns1__S1_USCORE020--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__S1_USCORE020(struct soap *soap, const struct __ns3__S1_USCORE020 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__S1_USCORE020(soap, tag?tag:"-ns3:S1_020", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__S1_USCORE020 * SOAP_FMAC4 soap_get___ns3__S1_USCORE020(struct soap *soap, struct __ns3__S1_USCORE020 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__S1_USCORE020(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__S1_USCORE020 * SOAP_FMAC2 soap_instantiate___ns3__S1_USCORE020(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__S1_USCORE020(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__S1_USCORE020, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__S1_USCORE020);
		if (size)
			*size = sizeof(struct __ns3__S1_USCORE020);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__S1_USCORE020[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__S1_USCORE020);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__S1_USCORE020*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__S1_USCORE020(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__S1_USCORE020 %p -> %p\n", q, p));
	*(struct __ns3__S1_USCORE020*)p = *(struct __ns3__S1_USCORE020*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__S1_USCORE019(struct soap *soap, struct __ns3__S1_USCORE019 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__S1_USCORE019 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__S1_USCORE019(struct soap *soap, const struct __ns3__S1_USCORE019 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__S1_USCORE019(soap, &a->ns1__S1_USCORE019);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__S1_USCORE019(struct soap *soap, const char *tag, int id, const struct __ns3__S1_USCORE019 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__S1_USCORE019(soap, "ns1:S1_019", -1, &a->ns1__S1_USCORE019, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__S1_USCORE019 * SOAP_FMAC4 soap_in___ns3__S1_USCORE019(struct soap *soap, const char *tag, struct __ns3__S1_USCORE019 *a, const char *type)
{
	size_t soap_flag_ns1__S1_USCORE019 = 1;
	short soap_flag;
	a = (struct __ns3__S1_USCORE019 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__S1_USCORE019, sizeof(struct __ns3__S1_USCORE019), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__S1_USCORE019(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__S1_USCORE019 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__S1_USCORE019(soap, "ns1:S1_019", &a->ns1__S1_USCORE019, ""))
				{	soap_flag_ns1__S1_USCORE019--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__S1_USCORE019(struct soap *soap, const struct __ns3__S1_USCORE019 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__S1_USCORE019(soap, tag?tag:"-ns3:S1_019", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__S1_USCORE019 * SOAP_FMAC4 soap_get___ns3__S1_USCORE019(struct soap *soap, struct __ns3__S1_USCORE019 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__S1_USCORE019(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__S1_USCORE019 * SOAP_FMAC2 soap_instantiate___ns3__S1_USCORE019(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__S1_USCORE019(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__S1_USCORE019, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__S1_USCORE019);
		if (size)
			*size = sizeof(struct __ns3__S1_USCORE019);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__S1_USCORE019[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__S1_USCORE019);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__S1_USCORE019*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__S1_USCORE019(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__S1_USCORE019 %p -> %p\n", q, p));
	*(struct __ns3__S1_USCORE019*)p = *(struct __ns3__S1_USCORE019*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__S1_USCORE018(struct soap *soap, struct __ns3__S1_USCORE018 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__S1_USCORE018 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__S1_USCORE018(struct soap *soap, const struct __ns3__S1_USCORE018 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__S1_USCORE018(soap, &a->ns1__S1_USCORE018);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__S1_USCORE018(struct soap *soap, const char *tag, int id, const struct __ns3__S1_USCORE018 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__S1_USCORE018(soap, "ns1:S1_018", -1, &a->ns1__S1_USCORE018, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__S1_USCORE018 * SOAP_FMAC4 soap_in___ns3__S1_USCORE018(struct soap *soap, const char *tag, struct __ns3__S1_USCORE018 *a, const char *type)
{
	size_t soap_flag_ns1__S1_USCORE018 = 1;
	short soap_flag;
	a = (struct __ns3__S1_USCORE018 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__S1_USCORE018, sizeof(struct __ns3__S1_USCORE018), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__S1_USCORE018(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__S1_USCORE018 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__S1_USCORE018(soap, "ns1:S1_018", &a->ns1__S1_USCORE018, ""))
				{	soap_flag_ns1__S1_USCORE018--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__S1_USCORE018(struct soap *soap, const struct __ns3__S1_USCORE018 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__S1_USCORE018(soap, tag?tag:"-ns3:S1_018", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__S1_USCORE018 * SOAP_FMAC4 soap_get___ns3__S1_USCORE018(struct soap *soap, struct __ns3__S1_USCORE018 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__S1_USCORE018(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__S1_USCORE018 * SOAP_FMAC2 soap_instantiate___ns3__S1_USCORE018(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__S1_USCORE018(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__S1_USCORE018, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__S1_USCORE018);
		if (size)
			*size = sizeof(struct __ns3__S1_USCORE018);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__S1_USCORE018[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__S1_USCORE018);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__S1_USCORE018*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__S1_USCORE018(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__S1_USCORE018 %p -> %p\n", q, p));
	*(struct __ns3__S1_USCORE018*)p = *(struct __ns3__S1_USCORE018*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__S1_USCORE009(struct soap *soap, struct __ns3__S1_USCORE009 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__S1_USCORE009 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__S1_USCORE009(struct soap *soap, const struct __ns3__S1_USCORE009 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__S1_USCORE009(soap, &a->ns1__S1_USCORE009);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__S1_USCORE009(struct soap *soap, const char *tag, int id, const struct __ns3__S1_USCORE009 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__S1_USCORE009(soap, "ns1:S1_009", -1, &a->ns1__S1_USCORE009, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__S1_USCORE009 * SOAP_FMAC4 soap_in___ns3__S1_USCORE009(struct soap *soap, const char *tag, struct __ns3__S1_USCORE009 *a, const char *type)
{
	size_t soap_flag_ns1__S1_USCORE009 = 1;
	short soap_flag;
	a = (struct __ns3__S1_USCORE009 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__S1_USCORE009, sizeof(struct __ns3__S1_USCORE009), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__S1_USCORE009(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__S1_USCORE009 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__S1_USCORE009(soap, "ns1:S1_009", &a->ns1__S1_USCORE009, ""))
				{	soap_flag_ns1__S1_USCORE009--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__S1_USCORE009(struct soap *soap, const struct __ns3__S1_USCORE009 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__S1_USCORE009(soap, tag?tag:"-ns3:S1_009", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__S1_USCORE009 * SOAP_FMAC4 soap_get___ns3__S1_USCORE009(struct soap *soap, struct __ns3__S1_USCORE009 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__S1_USCORE009(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__S1_USCORE009 * SOAP_FMAC2 soap_instantiate___ns3__S1_USCORE009(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__S1_USCORE009(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__S1_USCORE009, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__S1_USCORE009);
		if (size)
			*size = sizeof(struct __ns3__S1_USCORE009);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__S1_USCORE009[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__S1_USCORE009);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__S1_USCORE009*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__S1_USCORE009(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__S1_USCORE009 %p -> %p\n", q, p));
	*(struct __ns3__S1_USCORE009*)p = *(struct __ns3__S1_USCORE009*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__S1_USCORE005(struct soap *soap, struct __ns3__S1_USCORE005 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__S1_USCORE005 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__S1_USCORE005(struct soap *soap, const struct __ns3__S1_USCORE005 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__S1_USCORE005(soap, &a->ns1__S1_USCORE005);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__S1_USCORE005(struct soap *soap, const char *tag, int id, const struct __ns3__S1_USCORE005 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__S1_USCORE005(soap, "ns1:S1_005", -1, &a->ns1__S1_USCORE005, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__S1_USCORE005 * SOAP_FMAC4 soap_in___ns3__S1_USCORE005(struct soap *soap, const char *tag, struct __ns3__S1_USCORE005 *a, const char *type)
{
	size_t soap_flag_ns1__S1_USCORE005 = 1;
	short soap_flag;
	a = (struct __ns3__S1_USCORE005 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__S1_USCORE005, sizeof(struct __ns3__S1_USCORE005), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__S1_USCORE005(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__S1_USCORE005 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__S1_USCORE005(soap, "ns1:S1_005", &a->ns1__S1_USCORE005, ""))
				{	soap_flag_ns1__S1_USCORE005--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__S1_USCORE005(struct soap *soap, const struct __ns3__S1_USCORE005 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__S1_USCORE005(soap, tag?tag:"-ns3:S1_005", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__S1_USCORE005 * SOAP_FMAC4 soap_get___ns3__S1_USCORE005(struct soap *soap, struct __ns3__S1_USCORE005 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__S1_USCORE005(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__S1_USCORE005 * SOAP_FMAC2 soap_instantiate___ns3__S1_USCORE005(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__S1_USCORE005(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__S1_USCORE005, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__S1_USCORE005);
		if (size)
			*size = sizeof(struct __ns3__S1_USCORE005);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__S1_USCORE005[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__S1_USCORE005);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__S1_USCORE005*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__S1_USCORE005(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__S1_USCORE005 %p -> %p\n", q, p));
	*(struct __ns3__S1_USCORE005*)p = *(struct __ns3__S1_USCORE005*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__S1_USCORE004(struct soap *soap, struct __ns3__S1_USCORE004 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__S1_USCORE004 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__S1_USCORE004(struct soap *soap, const struct __ns3__S1_USCORE004 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__S1_USCORE004(soap, &a->ns1__S1_USCORE004);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__S1_USCORE004(struct soap *soap, const char *tag, int id, const struct __ns3__S1_USCORE004 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__S1_USCORE004(soap, "ns1:S1_004", -1, &a->ns1__S1_USCORE004, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__S1_USCORE004 * SOAP_FMAC4 soap_in___ns3__S1_USCORE004(struct soap *soap, const char *tag, struct __ns3__S1_USCORE004 *a, const char *type)
{
	size_t soap_flag_ns1__S1_USCORE004 = 1;
	short soap_flag;
	a = (struct __ns3__S1_USCORE004 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__S1_USCORE004, sizeof(struct __ns3__S1_USCORE004), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__S1_USCORE004(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__S1_USCORE004 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__S1_USCORE004(soap, "ns1:S1_004", &a->ns1__S1_USCORE004, ""))
				{	soap_flag_ns1__S1_USCORE004--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__S1_USCORE004(struct soap *soap, const struct __ns3__S1_USCORE004 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__S1_USCORE004(soap, tag?tag:"-ns3:S1_004", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__S1_USCORE004 * SOAP_FMAC4 soap_get___ns3__S1_USCORE004(struct soap *soap, struct __ns3__S1_USCORE004 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__S1_USCORE004(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__S1_USCORE004 * SOAP_FMAC2 soap_instantiate___ns3__S1_USCORE004(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__S1_USCORE004(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__S1_USCORE004, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__S1_USCORE004);
		if (size)
			*size = sizeof(struct __ns3__S1_USCORE004);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__S1_USCORE004[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__S1_USCORE004);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__S1_USCORE004*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__S1_USCORE004(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__S1_USCORE004 %p -> %p\n", q, p));
	*(struct __ns3__S1_USCORE004*)p = *(struct __ns3__S1_USCORE004*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__S1_USCORE001(struct soap *soap, struct __ns3__S1_USCORE001 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__S1_USCORE001 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__S1_USCORE001(struct soap *soap, const struct __ns3__S1_USCORE001 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__S1_USCORE001(soap, &a->ns1__S1_USCORE001);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__S1_USCORE001(struct soap *soap, const char *tag, int id, const struct __ns3__S1_USCORE001 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__S1_USCORE001(soap, "ns1:S1_001", -1, &a->ns1__S1_USCORE001, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__S1_USCORE001 * SOAP_FMAC4 soap_in___ns3__S1_USCORE001(struct soap *soap, const char *tag, struct __ns3__S1_USCORE001 *a, const char *type)
{
	size_t soap_flag_ns1__S1_USCORE001 = 1;
	short soap_flag;
	a = (struct __ns3__S1_USCORE001 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__S1_USCORE001, sizeof(struct __ns3__S1_USCORE001), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__S1_USCORE001(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__S1_USCORE001 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__S1_USCORE001(soap, "ns1:S1_001", &a->ns1__S1_USCORE001, ""))
				{	soap_flag_ns1__S1_USCORE001--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__S1_USCORE001(struct soap *soap, const struct __ns3__S1_USCORE001 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__S1_USCORE001(soap, tag?tag:"-ns3:S1_001", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__S1_USCORE001 * SOAP_FMAC4 soap_get___ns3__S1_USCORE001(struct soap *soap, struct __ns3__S1_USCORE001 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__S1_USCORE001(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__S1_USCORE001 * SOAP_FMAC2 soap_instantiate___ns3__S1_USCORE001(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__S1_USCORE001(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__S1_USCORE001, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__S1_USCORE001);
		if (size)
			*size = sizeof(struct __ns3__S1_USCORE001);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns3__S1_USCORE001[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__S1_USCORE001);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__S1_USCORE001*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__S1_USCORE001(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__S1_USCORE001 %p -> %p\n", q, p));
	*(struct __ns3__S1_USCORE001*)p = *(struct __ns3__S1_USCORE001*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__S1_USCORE020(struct soap *soap, struct __ns2__S1_USCORE020 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__S1_USCORE020 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__S1_USCORE020(struct soap *soap, const struct __ns2__S1_USCORE020 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__S1_USCORE020(soap, &a->ns1__S1_USCORE020);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__S1_USCORE020(struct soap *soap, const char *tag, int id, const struct __ns2__S1_USCORE020 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__S1_USCORE020(soap, "ns1:S1_020", -1, &a->ns1__S1_USCORE020, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__S1_USCORE020 * SOAP_FMAC4 soap_in___ns2__S1_USCORE020(struct soap *soap, const char *tag, struct __ns2__S1_USCORE020 *a, const char *type)
{
	size_t soap_flag_ns1__S1_USCORE020 = 1;
	short soap_flag;
	a = (struct __ns2__S1_USCORE020 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__S1_USCORE020, sizeof(struct __ns2__S1_USCORE020), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__S1_USCORE020(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__S1_USCORE020 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__S1_USCORE020(soap, "ns1:S1_020", &a->ns1__S1_USCORE020, ""))
				{	soap_flag_ns1__S1_USCORE020--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__S1_USCORE020(struct soap *soap, const struct __ns2__S1_USCORE020 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__S1_USCORE020(soap, tag?tag:"-ns2:S1_020", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__S1_USCORE020 * SOAP_FMAC4 soap_get___ns2__S1_USCORE020(struct soap *soap, struct __ns2__S1_USCORE020 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__S1_USCORE020(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__S1_USCORE020 * SOAP_FMAC2 soap_instantiate___ns2__S1_USCORE020(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__S1_USCORE020(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__S1_USCORE020, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__S1_USCORE020);
		if (size)
			*size = sizeof(struct __ns2__S1_USCORE020);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__S1_USCORE020[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__S1_USCORE020);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__S1_USCORE020*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__S1_USCORE020(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__S1_USCORE020 %p -> %p\n", q, p));
	*(struct __ns2__S1_USCORE020*)p = *(struct __ns2__S1_USCORE020*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__S1_USCORE019(struct soap *soap, struct __ns2__S1_USCORE019 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__S1_USCORE019 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__S1_USCORE019(struct soap *soap, const struct __ns2__S1_USCORE019 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__S1_USCORE019(soap, &a->ns1__S1_USCORE019);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__S1_USCORE019(struct soap *soap, const char *tag, int id, const struct __ns2__S1_USCORE019 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__S1_USCORE019(soap, "ns1:S1_019", -1, &a->ns1__S1_USCORE019, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__S1_USCORE019 * SOAP_FMAC4 soap_in___ns2__S1_USCORE019(struct soap *soap, const char *tag, struct __ns2__S1_USCORE019 *a, const char *type)
{
	size_t soap_flag_ns1__S1_USCORE019 = 1;
	short soap_flag;
	a = (struct __ns2__S1_USCORE019 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__S1_USCORE019, sizeof(struct __ns2__S1_USCORE019), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__S1_USCORE019(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__S1_USCORE019 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__S1_USCORE019(soap, "ns1:S1_019", &a->ns1__S1_USCORE019, ""))
				{	soap_flag_ns1__S1_USCORE019--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__S1_USCORE019(struct soap *soap, const struct __ns2__S1_USCORE019 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__S1_USCORE019(soap, tag?tag:"-ns2:S1_019", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__S1_USCORE019 * SOAP_FMAC4 soap_get___ns2__S1_USCORE019(struct soap *soap, struct __ns2__S1_USCORE019 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__S1_USCORE019(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__S1_USCORE019 * SOAP_FMAC2 soap_instantiate___ns2__S1_USCORE019(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__S1_USCORE019(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__S1_USCORE019, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__S1_USCORE019);
		if (size)
			*size = sizeof(struct __ns2__S1_USCORE019);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__S1_USCORE019[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__S1_USCORE019);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__S1_USCORE019*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__S1_USCORE019(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__S1_USCORE019 %p -> %p\n", q, p));
	*(struct __ns2__S1_USCORE019*)p = *(struct __ns2__S1_USCORE019*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__S1_USCORE018(struct soap *soap, struct __ns2__S1_USCORE018 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__S1_USCORE018 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__S1_USCORE018(struct soap *soap, const struct __ns2__S1_USCORE018 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__S1_USCORE018(soap, &a->ns1__S1_USCORE018);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__S1_USCORE018(struct soap *soap, const char *tag, int id, const struct __ns2__S1_USCORE018 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__S1_USCORE018(soap, "ns1:S1_018", -1, &a->ns1__S1_USCORE018, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__S1_USCORE018 * SOAP_FMAC4 soap_in___ns2__S1_USCORE018(struct soap *soap, const char *tag, struct __ns2__S1_USCORE018 *a, const char *type)
{
	size_t soap_flag_ns1__S1_USCORE018 = 1;
	short soap_flag;
	a = (struct __ns2__S1_USCORE018 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__S1_USCORE018, sizeof(struct __ns2__S1_USCORE018), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__S1_USCORE018(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__S1_USCORE018 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__S1_USCORE018(soap, "ns1:S1_018", &a->ns1__S1_USCORE018, ""))
				{	soap_flag_ns1__S1_USCORE018--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__S1_USCORE018(struct soap *soap, const struct __ns2__S1_USCORE018 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__S1_USCORE018(soap, tag?tag:"-ns2:S1_018", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__S1_USCORE018 * SOAP_FMAC4 soap_get___ns2__S1_USCORE018(struct soap *soap, struct __ns2__S1_USCORE018 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__S1_USCORE018(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__S1_USCORE018 * SOAP_FMAC2 soap_instantiate___ns2__S1_USCORE018(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__S1_USCORE018(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__S1_USCORE018, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__S1_USCORE018);
		if (size)
			*size = sizeof(struct __ns2__S1_USCORE018);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__S1_USCORE018[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__S1_USCORE018);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__S1_USCORE018*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__S1_USCORE018(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__S1_USCORE018 %p -> %p\n", q, p));
	*(struct __ns2__S1_USCORE018*)p = *(struct __ns2__S1_USCORE018*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__S1_USCORE009(struct soap *soap, struct __ns2__S1_USCORE009 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__S1_USCORE009 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__S1_USCORE009(struct soap *soap, const struct __ns2__S1_USCORE009 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__S1_USCORE009(soap, &a->ns1__S1_USCORE009);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__S1_USCORE009(struct soap *soap, const char *tag, int id, const struct __ns2__S1_USCORE009 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__S1_USCORE009(soap, "ns1:S1_009", -1, &a->ns1__S1_USCORE009, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__S1_USCORE009 * SOAP_FMAC4 soap_in___ns2__S1_USCORE009(struct soap *soap, const char *tag, struct __ns2__S1_USCORE009 *a, const char *type)
{
	size_t soap_flag_ns1__S1_USCORE009 = 1;
	short soap_flag;
	a = (struct __ns2__S1_USCORE009 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__S1_USCORE009, sizeof(struct __ns2__S1_USCORE009), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__S1_USCORE009(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__S1_USCORE009 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__S1_USCORE009(soap, "ns1:S1_009", &a->ns1__S1_USCORE009, ""))
				{	soap_flag_ns1__S1_USCORE009--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__S1_USCORE009(struct soap *soap, const struct __ns2__S1_USCORE009 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__S1_USCORE009(soap, tag?tag:"-ns2:S1_009", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__S1_USCORE009 * SOAP_FMAC4 soap_get___ns2__S1_USCORE009(struct soap *soap, struct __ns2__S1_USCORE009 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__S1_USCORE009(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__S1_USCORE009 * SOAP_FMAC2 soap_instantiate___ns2__S1_USCORE009(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__S1_USCORE009(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__S1_USCORE009, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__S1_USCORE009);
		if (size)
			*size = sizeof(struct __ns2__S1_USCORE009);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__S1_USCORE009[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__S1_USCORE009);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__S1_USCORE009*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__S1_USCORE009(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__S1_USCORE009 %p -> %p\n", q, p));
	*(struct __ns2__S1_USCORE009*)p = *(struct __ns2__S1_USCORE009*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__S1_USCORE005(struct soap *soap, struct __ns2__S1_USCORE005 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__S1_USCORE005 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__S1_USCORE005(struct soap *soap, const struct __ns2__S1_USCORE005 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__S1_USCORE005(soap, &a->ns1__S1_USCORE005);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__S1_USCORE005(struct soap *soap, const char *tag, int id, const struct __ns2__S1_USCORE005 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__S1_USCORE005(soap, "ns1:S1_005", -1, &a->ns1__S1_USCORE005, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__S1_USCORE005 * SOAP_FMAC4 soap_in___ns2__S1_USCORE005(struct soap *soap, const char *tag, struct __ns2__S1_USCORE005 *a, const char *type)
{
	size_t soap_flag_ns1__S1_USCORE005 = 1;
	short soap_flag;
	a = (struct __ns2__S1_USCORE005 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__S1_USCORE005, sizeof(struct __ns2__S1_USCORE005), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__S1_USCORE005(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__S1_USCORE005 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__S1_USCORE005(soap, "ns1:S1_005", &a->ns1__S1_USCORE005, ""))
				{	soap_flag_ns1__S1_USCORE005--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__S1_USCORE005(struct soap *soap, const struct __ns2__S1_USCORE005 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__S1_USCORE005(soap, tag?tag:"-ns2:S1_005", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__S1_USCORE005 * SOAP_FMAC4 soap_get___ns2__S1_USCORE005(struct soap *soap, struct __ns2__S1_USCORE005 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__S1_USCORE005(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__S1_USCORE005 * SOAP_FMAC2 soap_instantiate___ns2__S1_USCORE005(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__S1_USCORE005(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__S1_USCORE005, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__S1_USCORE005);
		if (size)
			*size = sizeof(struct __ns2__S1_USCORE005);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__S1_USCORE005[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__S1_USCORE005);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__S1_USCORE005*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__S1_USCORE005(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__S1_USCORE005 %p -> %p\n", q, p));
	*(struct __ns2__S1_USCORE005*)p = *(struct __ns2__S1_USCORE005*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__S1_USCORE004(struct soap *soap, struct __ns2__S1_USCORE004 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__S1_USCORE004 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__S1_USCORE004(struct soap *soap, const struct __ns2__S1_USCORE004 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__S1_USCORE004(soap, &a->ns1__S1_USCORE004);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__S1_USCORE004(struct soap *soap, const char *tag, int id, const struct __ns2__S1_USCORE004 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__S1_USCORE004(soap, "ns1:S1_004", -1, &a->ns1__S1_USCORE004, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__S1_USCORE004 * SOAP_FMAC4 soap_in___ns2__S1_USCORE004(struct soap *soap, const char *tag, struct __ns2__S1_USCORE004 *a, const char *type)
{
	size_t soap_flag_ns1__S1_USCORE004 = 1;
	short soap_flag;
	a = (struct __ns2__S1_USCORE004 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__S1_USCORE004, sizeof(struct __ns2__S1_USCORE004), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__S1_USCORE004(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__S1_USCORE004 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__S1_USCORE004(soap, "ns1:S1_004", &a->ns1__S1_USCORE004, ""))
				{	soap_flag_ns1__S1_USCORE004--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__S1_USCORE004(struct soap *soap, const struct __ns2__S1_USCORE004 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__S1_USCORE004(soap, tag?tag:"-ns2:S1_004", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__S1_USCORE004 * SOAP_FMAC4 soap_get___ns2__S1_USCORE004(struct soap *soap, struct __ns2__S1_USCORE004 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__S1_USCORE004(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__S1_USCORE004 * SOAP_FMAC2 soap_instantiate___ns2__S1_USCORE004(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__S1_USCORE004(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__S1_USCORE004, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__S1_USCORE004);
		if (size)
			*size = sizeof(struct __ns2__S1_USCORE004);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__S1_USCORE004[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__S1_USCORE004);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__S1_USCORE004*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__S1_USCORE004(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__S1_USCORE004 %p -> %p\n", q, p));
	*(struct __ns2__S1_USCORE004*)p = *(struct __ns2__S1_USCORE004*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__S1_USCORE001(struct soap *soap, struct __ns2__S1_USCORE001 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__S1_USCORE001 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__S1_USCORE001(struct soap *soap, const struct __ns2__S1_USCORE001 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__S1_USCORE001(soap, &a->ns1__S1_USCORE001);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__S1_USCORE001(struct soap *soap, const char *tag, int id, const struct __ns2__S1_USCORE001 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__S1_USCORE001(soap, "ns1:S1_001", -1, &a->ns1__S1_USCORE001, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__S1_USCORE001 * SOAP_FMAC4 soap_in___ns2__S1_USCORE001(struct soap *soap, const char *tag, struct __ns2__S1_USCORE001 *a, const char *type)
{
	size_t soap_flag_ns1__S1_USCORE001 = 1;
	short soap_flag;
	a = (struct __ns2__S1_USCORE001 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__S1_USCORE001, sizeof(struct __ns2__S1_USCORE001), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__S1_USCORE001(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__S1_USCORE001 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__S1_USCORE001(soap, "ns1:S1_001", &a->ns1__S1_USCORE001, ""))
				{	soap_flag_ns1__S1_USCORE001--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__S1_USCORE001(struct soap *soap, const struct __ns2__S1_USCORE001 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__S1_USCORE001(soap, tag?tag:"-ns2:S1_001", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__S1_USCORE001 * SOAP_FMAC4 soap_get___ns2__S1_USCORE001(struct soap *soap, struct __ns2__S1_USCORE001 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__S1_USCORE001(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__S1_USCORE001 * SOAP_FMAC2 soap_instantiate___ns2__S1_USCORE001(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__S1_USCORE001(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__S1_USCORE001, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__S1_USCORE001);
		if (size)
			*size = sizeof(struct __ns2__S1_USCORE001);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__S1_USCORE001[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__S1_USCORE001);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__S1_USCORE001*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__S1_USCORE001(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__S1_USCORE001 %p -> %p\n", q, p));
	*(struct __ns2__S1_USCORE001*)p = *(struct __ns2__S1_USCORE001*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__S1_USCORE020Response(struct soap *soap, _ns1__S1_USCORE020Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__S1_USCORE020Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__S1_USCORE020Response(struct soap *soap, const char *tag, int id, _ns1__S1_USCORE020Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__S1_USCORE020Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__S1_USCORE020Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__S1_USCORE020Response(struct soap *soap, const char *tag, _ns1__S1_USCORE020Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__S1_USCORE020Response **)soap_malloc(soap, sizeof(_ns1__S1_USCORE020Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__S1_USCORE020Response *)soap_instantiate__ns1__S1_USCORE020Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__S1_USCORE020Response ** p = (_ns1__S1_USCORE020Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__S1_USCORE020Response, sizeof(_ns1__S1_USCORE020Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__S1_USCORE020Response(struct soap *soap, _ns1__S1_USCORE020Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__S1_USCORE020Response);
	if (soap_out_PointerTo_ns1__S1_USCORE020Response(soap, tag?tag:"ns1:S1_020Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__S1_USCORE020Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__S1_USCORE020Response(struct soap *soap, _ns1__S1_USCORE020Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__S1_USCORE020Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__S1_USCORE020(struct soap *soap, _ns1__S1_USCORE020 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__S1_USCORE020))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__S1_USCORE020(struct soap *soap, const char *tag, int id, _ns1__S1_USCORE020 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__S1_USCORE020);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__S1_USCORE020 ** SOAP_FMAC4 soap_in_PointerTo_ns1__S1_USCORE020(struct soap *soap, const char *tag, _ns1__S1_USCORE020 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__S1_USCORE020 **)soap_malloc(soap, sizeof(_ns1__S1_USCORE020 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__S1_USCORE020 *)soap_instantiate__ns1__S1_USCORE020(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__S1_USCORE020 ** p = (_ns1__S1_USCORE020 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__S1_USCORE020, sizeof(_ns1__S1_USCORE020), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__S1_USCORE020(struct soap *soap, _ns1__S1_USCORE020 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__S1_USCORE020);
	if (soap_out_PointerTo_ns1__S1_USCORE020(soap, tag?tag:"ns1:S1_020", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__S1_USCORE020 ** SOAP_FMAC4 soap_get_PointerTo_ns1__S1_USCORE020(struct soap *soap, _ns1__S1_USCORE020 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__S1_USCORE020(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__S1_USCORE019Response(struct soap *soap, _ns1__S1_USCORE019Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__S1_USCORE019Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__S1_USCORE019Response(struct soap *soap, const char *tag, int id, _ns1__S1_USCORE019Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__S1_USCORE019Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__S1_USCORE019Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__S1_USCORE019Response(struct soap *soap, const char *tag, _ns1__S1_USCORE019Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__S1_USCORE019Response **)soap_malloc(soap, sizeof(_ns1__S1_USCORE019Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__S1_USCORE019Response *)soap_instantiate__ns1__S1_USCORE019Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__S1_USCORE019Response ** p = (_ns1__S1_USCORE019Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__S1_USCORE019Response, sizeof(_ns1__S1_USCORE019Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__S1_USCORE019Response(struct soap *soap, _ns1__S1_USCORE019Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__S1_USCORE019Response);
	if (soap_out_PointerTo_ns1__S1_USCORE019Response(soap, tag?tag:"ns1:S1_019Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__S1_USCORE019Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__S1_USCORE019Response(struct soap *soap, _ns1__S1_USCORE019Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__S1_USCORE019Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__S1_USCORE019(struct soap *soap, _ns1__S1_USCORE019 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__S1_USCORE019))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__S1_USCORE019(struct soap *soap, const char *tag, int id, _ns1__S1_USCORE019 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__S1_USCORE019);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__S1_USCORE019 ** SOAP_FMAC4 soap_in_PointerTo_ns1__S1_USCORE019(struct soap *soap, const char *tag, _ns1__S1_USCORE019 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__S1_USCORE019 **)soap_malloc(soap, sizeof(_ns1__S1_USCORE019 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__S1_USCORE019 *)soap_instantiate__ns1__S1_USCORE019(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__S1_USCORE019 ** p = (_ns1__S1_USCORE019 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__S1_USCORE019, sizeof(_ns1__S1_USCORE019), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__S1_USCORE019(struct soap *soap, _ns1__S1_USCORE019 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__S1_USCORE019);
	if (soap_out_PointerTo_ns1__S1_USCORE019(soap, tag?tag:"ns1:S1_019", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__S1_USCORE019 ** SOAP_FMAC4 soap_get_PointerTo_ns1__S1_USCORE019(struct soap *soap, _ns1__S1_USCORE019 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__S1_USCORE019(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__S1_USCORE018Response(struct soap *soap, _ns1__S1_USCORE018Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__S1_USCORE018Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__S1_USCORE018Response(struct soap *soap, const char *tag, int id, _ns1__S1_USCORE018Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__S1_USCORE018Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__S1_USCORE018Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__S1_USCORE018Response(struct soap *soap, const char *tag, _ns1__S1_USCORE018Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__S1_USCORE018Response **)soap_malloc(soap, sizeof(_ns1__S1_USCORE018Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__S1_USCORE018Response *)soap_instantiate__ns1__S1_USCORE018Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__S1_USCORE018Response ** p = (_ns1__S1_USCORE018Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__S1_USCORE018Response, sizeof(_ns1__S1_USCORE018Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__S1_USCORE018Response(struct soap *soap, _ns1__S1_USCORE018Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__S1_USCORE018Response);
	if (soap_out_PointerTo_ns1__S1_USCORE018Response(soap, tag?tag:"ns1:S1_018Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__S1_USCORE018Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__S1_USCORE018Response(struct soap *soap, _ns1__S1_USCORE018Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__S1_USCORE018Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__S1_USCORE018(struct soap *soap, _ns1__S1_USCORE018 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__S1_USCORE018))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__S1_USCORE018(struct soap *soap, const char *tag, int id, _ns1__S1_USCORE018 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__S1_USCORE018);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__S1_USCORE018 ** SOAP_FMAC4 soap_in_PointerTo_ns1__S1_USCORE018(struct soap *soap, const char *tag, _ns1__S1_USCORE018 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__S1_USCORE018 **)soap_malloc(soap, sizeof(_ns1__S1_USCORE018 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__S1_USCORE018 *)soap_instantiate__ns1__S1_USCORE018(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__S1_USCORE018 ** p = (_ns1__S1_USCORE018 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__S1_USCORE018, sizeof(_ns1__S1_USCORE018), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__S1_USCORE018(struct soap *soap, _ns1__S1_USCORE018 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__S1_USCORE018);
	if (soap_out_PointerTo_ns1__S1_USCORE018(soap, tag?tag:"ns1:S1_018", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__S1_USCORE018 ** SOAP_FMAC4 soap_get_PointerTo_ns1__S1_USCORE018(struct soap *soap, _ns1__S1_USCORE018 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__S1_USCORE018(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__S1_USCORE009Response(struct soap *soap, _ns1__S1_USCORE009Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__S1_USCORE009Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__S1_USCORE009Response(struct soap *soap, const char *tag, int id, _ns1__S1_USCORE009Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__S1_USCORE009Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__S1_USCORE009Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__S1_USCORE009Response(struct soap *soap, const char *tag, _ns1__S1_USCORE009Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__S1_USCORE009Response **)soap_malloc(soap, sizeof(_ns1__S1_USCORE009Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__S1_USCORE009Response *)soap_instantiate__ns1__S1_USCORE009Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__S1_USCORE009Response ** p = (_ns1__S1_USCORE009Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__S1_USCORE009Response, sizeof(_ns1__S1_USCORE009Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__S1_USCORE009Response(struct soap *soap, _ns1__S1_USCORE009Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__S1_USCORE009Response);
	if (soap_out_PointerTo_ns1__S1_USCORE009Response(soap, tag?tag:"ns1:S1_009Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__S1_USCORE009Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__S1_USCORE009Response(struct soap *soap, _ns1__S1_USCORE009Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__S1_USCORE009Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__S1_USCORE009(struct soap *soap, _ns1__S1_USCORE009 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__S1_USCORE009))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__S1_USCORE009(struct soap *soap, const char *tag, int id, _ns1__S1_USCORE009 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__S1_USCORE009);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__S1_USCORE009 ** SOAP_FMAC4 soap_in_PointerTo_ns1__S1_USCORE009(struct soap *soap, const char *tag, _ns1__S1_USCORE009 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__S1_USCORE009 **)soap_malloc(soap, sizeof(_ns1__S1_USCORE009 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__S1_USCORE009 *)soap_instantiate__ns1__S1_USCORE009(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__S1_USCORE009 ** p = (_ns1__S1_USCORE009 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__S1_USCORE009, sizeof(_ns1__S1_USCORE009), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__S1_USCORE009(struct soap *soap, _ns1__S1_USCORE009 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__S1_USCORE009);
	if (soap_out_PointerTo_ns1__S1_USCORE009(soap, tag?tag:"ns1:S1_009", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__S1_USCORE009 ** SOAP_FMAC4 soap_get_PointerTo_ns1__S1_USCORE009(struct soap *soap, _ns1__S1_USCORE009 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__S1_USCORE009(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__S1_USCORE005Response(struct soap *soap, _ns1__S1_USCORE005Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__S1_USCORE005Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__S1_USCORE005Response(struct soap *soap, const char *tag, int id, _ns1__S1_USCORE005Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__S1_USCORE005Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__S1_USCORE005Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__S1_USCORE005Response(struct soap *soap, const char *tag, _ns1__S1_USCORE005Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__S1_USCORE005Response **)soap_malloc(soap, sizeof(_ns1__S1_USCORE005Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__S1_USCORE005Response *)soap_instantiate__ns1__S1_USCORE005Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__S1_USCORE005Response ** p = (_ns1__S1_USCORE005Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__S1_USCORE005Response, sizeof(_ns1__S1_USCORE005Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__S1_USCORE005Response(struct soap *soap, _ns1__S1_USCORE005Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__S1_USCORE005Response);
	if (soap_out_PointerTo_ns1__S1_USCORE005Response(soap, tag?tag:"ns1:S1_005Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__S1_USCORE005Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__S1_USCORE005Response(struct soap *soap, _ns1__S1_USCORE005Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__S1_USCORE005Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__S1_USCORE005(struct soap *soap, _ns1__S1_USCORE005 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__S1_USCORE005))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__S1_USCORE005(struct soap *soap, const char *tag, int id, _ns1__S1_USCORE005 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__S1_USCORE005);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__S1_USCORE005 ** SOAP_FMAC4 soap_in_PointerTo_ns1__S1_USCORE005(struct soap *soap, const char *tag, _ns1__S1_USCORE005 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__S1_USCORE005 **)soap_malloc(soap, sizeof(_ns1__S1_USCORE005 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__S1_USCORE005 *)soap_instantiate__ns1__S1_USCORE005(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__S1_USCORE005 ** p = (_ns1__S1_USCORE005 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__S1_USCORE005, sizeof(_ns1__S1_USCORE005), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__S1_USCORE005(struct soap *soap, _ns1__S1_USCORE005 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__S1_USCORE005);
	if (soap_out_PointerTo_ns1__S1_USCORE005(soap, tag?tag:"ns1:S1_005", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__S1_USCORE005 ** SOAP_FMAC4 soap_get_PointerTo_ns1__S1_USCORE005(struct soap *soap, _ns1__S1_USCORE005 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__S1_USCORE005(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__S1_USCORE004Response(struct soap *soap, _ns1__S1_USCORE004Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__S1_USCORE004Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__S1_USCORE004Response(struct soap *soap, const char *tag, int id, _ns1__S1_USCORE004Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__S1_USCORE004Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__S1_USCORE004Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__S1_USCORE004Response(struct soap *soap, const char *tag, _ns1__S1_USCORE004Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__S1_USCORE004Response **)soap_malloc(soap, sizeof(_ns1__S1_USCORE004Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__S1_USCORE004Response *)soap_instantiate__ns1__S1_USCORE004Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__S1_USCORE004Response ** p = (_ns1__S1_USCORE004Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__S1_USCORE004Response, sizeof(_ns1__S1_USCORE004Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__S1_USCORE004Response(struct soap *soap, _ns1__S1_USCORE004Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__S1_USCORE004Response);
	if (soap_out_PointerTo_ns1__S1_USCORE004Response(soap, tag?tag:"ns1:S1_004Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__S1_USCORE004Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__S1_USCORE004Response(struct soap *soap, _ns1__S1_USCORE004Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__S1_USCORE004Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__S1_USCORE004(struct soap *soap, _ns1__S1_USCORE004 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__S1_USCORE004))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__S1_USCORE004(struct soap *soap, const char *tag, int id, _ns1__S1_USCORE004 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__S1_USCORE004);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__S1_USCORE004 ** SOAP_FMAC4 soap_in_PointerTo_ns1__S1_USCORE004(struct soap *soap, const char *tag, _ns1__S1_USCORE004 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__S1_USCORE004 **)soap_malloc(soap, sizeof(_ns1__S1_USCORE004 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__S1_USCORE004 *)soap_instantiate__ns1__S1_USCORE004(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__S1_USCORE004 ** p = (_ns1__S1_USCORE004 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__S1_USCORE004, sizeof(_ns1__S1_USCORE004), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__S1_USCORE004(struct soap *soap, _ns1__S1_USCORE004 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__S1_USCORE004);
	if (soap_out_PointerTo_ns1__S1_USCORE004(soap, tag?tag:"ns1:S1_004", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__S1_USCORE004 ** SOAP_FMAC4 soap_get_PointerTo_ns1__S1_USCORE004(struct soap *soap, _ns1__S1_USCORE004 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__S1_USCORE004(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__S1_USCORE001Response(struct soap *soap, _ns1__S1_USCORE001Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__S1_USCORE001Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__S1_USCORE001Response(struct soap *soap, const char *tag, int id, _ns1__S1_USCORE001Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__S1_USCORE001Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__S1_USCORE001Response ** SOAP_FMAC4 soap_in_PointerTo_ns1__S1_USCORE001Response(struct soap *soap, const char *tag, _ns1__S1_USCORE001Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__S1_USCORE001Response **)soap_malloc(soap, sizeof(_ns1__S1_USCORE001Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__S1_USCORE001Response *)soap_instantiate__ns1__S1_USCORE001Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__S1_USCORE001Response ** p = (_ns1__S1_USCORE001Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__S1_USCORE001Response, sizeof(_ns1__S1_USCORE001Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__S1_USCORE001Response(struct soap *soap, _ns1__S1_USCORE001Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__S1_USCORE001Response);
	if (soap_out_PointerTo_ns1__S1_USCORE001Response(soap, tag?tag:"ns1:S1_001Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__S1_USCORE001Response ** SOAP_FMAC4 soap_get_PointerTo_ns1__S1_USCORE001Response(struct soap *soap, _ns1__S1_USCORE001Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__S1_USCORE001Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__S1_USCORE001(struct soap *soap, _ns1__S1_USCORE001 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__S1_USCORE001))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__S1_USCORE001(struct soap *soap, const char *tag, int id, _ns1__S1_USCORE001 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__S1_USCORE001);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__S1_USCORE001 ** SOAP_FMAC4 soap_in_PointerTo_ns1__S1_USCORE001(struct soap *soap, const char *tag, _ns1__S1_USCORE001 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__S1_USCORE001 **)soap_malloc(soap, sizeof(_ns1__S1_USCORE001 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__S1_USCORE001 *)soap_instantiate__ns1__S1_USCORE001(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__S1_USCORE001 ** p = (_ns1__S1_USCORE001 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__S1_USCORE001, sizeof(_ns1__S1_USCORE001), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__S1_USCORE001(struct soap *soap, _ns1__S1_USCORE001 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__S1_USCORE001);
	if (soap_out_PointerTo_ns1__S1_USCORE001(soap, tag?tag:"ns1:S1_001", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__S1_USCORE001 ** SOAP_FMAC4 soap_get_PointerTo_ns1__S1_USCORE001(struct soap *soap, _ns1__S1_USCORE001 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__S1_USCORE001(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfString))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, int id, ns1__ArrayOfString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfString);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfString ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfString **)soap_malloc(soap, sizeof(ns1__ArrayOfString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfString *)soap_instantiate_ns1__ArrayOfString(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfString ** p = (ns1__ArrayOfString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfString);
	if (soap_out_PointerTons1__ArrayOfString(soap, tag?tag:"ns1:ArrayOfString", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfString ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SnapQRCodeTakeOrderQueryResp(struct soap *soap, ns1__SnapQRCodeTakeOrderQueryResp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SnapQRCodeTakeOrderQueryResp(struct soap *soap, const char *tag, int id, ns1__SnapQRCodeTakeOrderQueryResp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SnapQRCodeTakeOrderQueryResp ** SOAP_FMAC4 soap_in_PointerTons1__SnapQRCodeTakeOrderQueryResp(struct soap *soap, const char *tag, ns1__SnapQRCodeTakeOrderQueryResp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SnapQRCodeTakeOrderQueryResp **)soap_malloc(soap, sizeof(ns1__SnapQRCodeTakeOrderQueryResp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SnapQRCodeTakeOrderQueryResp *)soap_instantiate_ns1__SnapQRCodeTakeOrderQueryResp(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SnapQRCodeTakeOrderQueryResp ** p = (ns1__SnapQRCodeTakeOrderQueryResp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryResp, sizeof(ns1__SnapQRCodeTakeOrderQueryResp), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SnapQRCodeTakeOrderQueryResp(struct soap *soap, ns1__SnapQRCodeTakeOrderQueryResp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SnapQRCodeTakeOrderQueryResp);
	if (soap_out_PointerTons1__SnapQRCodeTakeOrderQueryResp(soap, tag?tag:"ns1:SnapQRCodeTakeOrderQueryResp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SnapQRCodeTakeOrderQueryResp ** SOAP_FMAC4 soap_get_PointerTons1__SnapQRCodeTakeOrderQueryResp(struct soap *soap, ns1__SnapQRCodeTakeOrderQueryResp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SnapQRCodeTakeOrderQueryResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SnapQRCodeTakeOrderQueryReq(struct soap *soap, ns1__SnapQRCodeTakeOrderQueryReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SnapQRCodeTakeOrderQueryReq(struct soap *soap, const char *tag, int id, ns1__SnapQRCodeTakeOrderQueryReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SnapQRCodeTakeOrderQueryReq ** SOAP_FMAC4 soap_in_PointerTons1__SnapQRCodeTakeOrderQueryReq(struct soap *soap, const char *tag, ns1__SnapQRCodeTakeOrderQueryReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SnapQRCodeTakeOrderQueryReq **)soap_malloc(soap, sizeof(ns1__SnapQRCodeTakeOrderQueryReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SnapQRCodeTakeOrderQueryReq *)soap_instantiate_ns1__SnapQRCodeTakeOrderQueryReq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SnapQRCodeTakeOrderQueryReq ** p = (ns1__SnapQRCodeTakeOrderQueryReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SnapQRCodeTakeOrderQueryReq, sizeof(ns1__SnapQRCodeTakeOrderQueryReq), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SnapQRCodeTakeOrderQueryReq(struct soap *soap, ns1__SnapQRCodeTakeOrderQueryReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SnapQRCodeTakeOrderQueryReq);
	if (soap_out_PointerTons1__SnapQRCodeTakeOrderQueryReq(soap, tag?tag:"ns1:SnapQRCodeTakeOrderQueryReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SnapQRCodeTakeOrderQueryReq ** SOAP_FMAC4 soap_get_PointerTons1__SnapQRCodeTakeOrderQueryReq(struct soap *soap, ns1__SnapQRCodeTakeOrderQueryReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SnapQRCodeTakeOrderQueryReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SnapQRCodePayResultQueryResp(struct soap *soap, ns1__SnapQRCodePayResultQueryResp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SnapQRCodePayResultQueryResp(struct soap *soap, const char *tag, int id, ns1__SnapQRCodePayResultQueryResp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SnapQRCodePayResultQueryResp ** SOAP_FMAC4 soap_in_PointerTons1__SnapQRCodePayResultQueryResp(struct soap *soap, const char *tag, ns1__SnapQRCodePayResultQueryResp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SnapQRCodePayResultQueryResp **)soap_malloc(soap, sizeof(ns1__SnapQRCodePayResultQueryResp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SnapQRCodePayResultQueryResp *)soap_instantiate_ns1__SnapQRCodePayResultQueryResp(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SnapQRCodePayResultQueryResp ** p = (ns1__SnapQRCodePayResultQueryResp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SnapQRCodePayResultQueryResp, sizeof(ns1__SnapQRCodePayResultQueryResp), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SnapQRCodePayResultQueryResp(struct soap *soap, ns1__SnapQRCodePayResultQueryResp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SnapQRCodePayResultQueryResp);
	if (soap_out_PointerTons1__SnapQRCodePayResultQueryResp(soap, tag?tag:"ns1:SnapQRCodePayResultQueryResp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SnapQRCodePayResultQueryResp ** SOAP_FMAC4 soap_get_PointerTons1__SnapQRCodePayResultQueryResp(struct soap *soap, ns1__SnapQRCodePayResultQueryResp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SnapQRCodePayResultQueryResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SnapQRCodePayResultQueryReq(struct soap *soap, ns1__SnapQRCodePayResultQueryReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SnapQRCodePayResultQueryReq(struct soap *soap, const char *tag, int id, ns1__SnapQRCodePayResultQueryReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SnapQRCodePayResultQueryReq ** SOAP_FMAC4 soap_in_PointerTons1__SnapQRCodePayResultQueryReq(struct soap *soap, const char *tag, ns1__SnapQRCodePayResultQueryReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SnapQRCodePayResultQueryReq **)soap_malloc(soap, sizeof(ns1__SnapQRCodePayResultQueryReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SnapQRCodePayResultQueryReq *)soap_instantiate_ns1__SnapQRCodePayResultQueryReq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SnapQRCodePayResultQueryReq ** p = (ns1__SnapQRCodePayResultQueryReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SnapQRCodePayResultQueryReq, sizeof(ns1__SnapQRCodePayResultQueryReq), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SnapQRCodePayResultQueryReq(struct soap *soap, ns1__SnapQRCodePayResultQueryReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SnapQRCodePayResultQueryReq);
	if (soap_out_PointerTons1__SnapQRCodePayResultQueryReq(soap, tag?tag:"ns1:SnapQRCodePayResultQueryReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SnapQRCodePayResultQueryReq ** SOAP_FMAC4 soap_get_PointerTons1__SnapQRCodePayResultQueryReq(struct soap *soap, ns1__SnapQRCodePayResultQueryReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SnapQRCodePayResultQueryReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SnapQRCodePrePayURLQueryResp(struct soap *soap, ns1__SnapQRCodePrePayURLQueryResp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SnapQRCodePrePayURLQueryResp(struct soap *soap, const char *tag, int id, ns1__SnapQRCodePrePayURLQueryResp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SnapQRCodePrePayURLQueryResp ** SOAP_FMAC4 soap_in_PointerTons1__SnapQRCodePrePayURLQueryResp(struct soap *soap, const char *tag, ns1__SnapQRCodePrePayURLQueryResp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SnapQRCodePrePayURLQueryResp **)soap_malloc(soap, sizeof(ns1__SnapQRCodePrePayURLQueryResp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SnapQRCodePrePayURLQueryResp *)soap_instantiate_ns1__SnapQRCodePrePayURLQueryResp(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SnapQRCodePrePayURLQueryResp ** p = (ns1__SnapQRCodePrePayURLQueryResp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryResp, sizeof(ns1__SnapQRCodePrePayURLQueryResp), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SnapQRCodePrePayURLQueryResp(struct soap *soap, ns1__SnapQRCodePrePayURLQueryResp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SnapQRCodePrePayURLQueryResp);
	if (soap_out_PointerTons1__SnapQRCodePrePayURLQueryResp(soap, tag?tag:"ns1:SnapQRCodePrePayURLQueryResp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SnapQRCodePrePayURLQueryResp ** SOAP_FMAC4 soap_get_PointerTons1__SnapQRCodePrePayURLQueryResp(struct soap *soap, ns1__SnapQRCodePrePayURLQueryResp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SnapQRCodePrePayURLQueryResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SnapQRCodePrePayURLQueryReq(struct soap *soap, ns1__SnapQRCodePrePayURLQueryReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SnapQRCodePrePayURLQueryReq(struct soap *soap, const char *tag, int id, ns1__SnapQRCodePrePayURLQueryReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SnapQRCodePrePayURLQueryReq ** SOAP_FMAC4 soap_in_PointerTons1__SnapQRCodePrePayURLQueryReq(struct soap *soap, const char *tag, ns1__SnapQRCodePrePayURLQueryReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SnapQRCodePrePayURLQueryReq **)soap_malloc(soap, sizeof(ns1__SnapQRCodePrePayURLQueryReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SnapQRCodePrePayURLQueryReq *)soap_instantiate_ns1__SnapQRCodePrePayURLQueryReq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SnapQRCodePrePayURLQueryReq ** p = (ns1__SnapQRCodePrePayURLQueryReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SnapQRCodePrePayURLQueryReq, sizeof(ns1__SnapQRCodePrePayURLQueryReq), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SnapQRCodePrePayURLQueryReq(struct soap *soap, ns1__SnapQRCodePrePayURLQueryReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SnapQRCodePrePayURLQueryReq);
	if (soap_out_PointerTons1__SnapQRCodePrePayURLQueryReq(soap, tag?tag:"ns1:SnapQRCodePrePayURLQueryReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SnapQRCodePrePayURLQueryReq ** SOAP_FMAC4 soap_get_PointerTons1__SnapQRCodePrePayURLQueryReq(struct soap *soap, ns1__SnapQRCodePrePayURLQueryReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SnapQRCodePrePayURLQueryReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HeartBeatResp(struct soap *soap, ns1__HeartBeatResp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HeartBeatResp))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HeartBeatResp(struct soap *soap, const char *tag, int id, ns1__HeartBeatResp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HeartBeatResp);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__HeartBeatResp ** SOAP_FMAC4 soap_in_PointerTons1__HeartBeatResp(struct soap *soap, const char *tag, ns1__HeartBeatResp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HeartBeatResp **)soap_malloc(soap, sizeof(ns1__HeartBeatResp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HeartBeatResp *)soap_instantiate_ns1__HeartBeatResp(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__HeartBeatResp ** p = (ns1__HeartBeatResp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HeartBeatResp, sizeof(ns1__HeartBeatResp), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HeartBeatResp(struct soap *soap, ns1__HeartBeatResp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HeartBeatResp);
	if (soap_out_PointerTons1__HeartBeatResp(soap, tag?tag:"ns1:HeartBeatResp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__HeartBeatResp ** SOAP_FMAC4 soap_get_PointerTons1__HeartBeatResp(struct soap *soap, ns1__HeartBeatResp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HeartBeatResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HeartBeatReq(struct soap *soap, ns1__HeartBeatReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HeartBeatReq))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HeartBeatReq(struct soap *soap, const char *tag, int id, ns1__HeartBeatReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HeartBeatReq);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__HeartBeatReq ** SOAP_FMAC4 soap_in_PointerTons1__HeartBeatReq(struct soap *soap, const char *tag, ns1__HeartBeatReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HeartBeatReq **)soap_malloc(soap, sizeof(ns1__HeartBeatReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HeartBeatReq *)soap_instantiate_ns1__HeartBeatReq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__HeartBeatReq ** p = (ns1__HeartBeatReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HeartBeatReq, sizeof(ns1__HeartBeatReq), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HeartBeatReq(struct soap *soap, ns1__HeartBeatReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HeartBeatReq);
	if (soap_out_PointerTons1__HeartBeatReq(soap, tag?tag:"ns1:HeartBeatReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__HeartBeatReq ** SOAP_FMAC4 soap_get_PointerTons1__HeartBeatReq(struct soap *soap, ns1__HeartBeatReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HeartBeatReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OrderExecuteFaultResp(struct soap *soap, ns1__OrderExecuteFaultResp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OrderExecuteFaultResp))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OrderExecuteFaultResp(struct soap *soap, const char *tag, int id, ns1__OrderExecuteFaultResp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OrderExecuteFaultResp);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__OrderExecuteFaultResp ** SOAP_FMAC4 soap_in_PointerTons1__OrderExecuteFaultResp(struct soap *soap, const char *tag, ns1__OrderExecuteFaultResp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OrderExecuteFaultResp **)soap_malloc(soap, sizeof(ns1__OrderExecuteFaultResp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OrderExecuteFaultResp *)soap_instantiate_ns1__OrderExecuteFaultResp(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__OrderExecuteFaultResp ** p = (ns1__OrderExecuteFaultResp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OrderExecuteFaultResp, sizeof(ns1__OrderExecuteFaultResp), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OrderExecuteFaultResp(struct soap *soap, ns1__OrderExecuteFaultResp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__OrderExecuteFaultResp);
	if (soap_out_PointerTons1__OrderExecuteFaultResp(soap, tag?tag:"ns1:OrderExecuteFaultResp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OrderExecuteFaultResp ** SOAP_FMAC4 soap_get_PointerTons1__OrderExecuteFaultResp(struct soap *soap, ns1__OrderExecuteFaultResp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OrderExecuteFaultResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OrderExecuteFaultReq(struct soap *soap, ns1__OrderExecuteFaultReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OrderExecuteFaultReq))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OrderExecuteFaultReq(struct soap *soap, const char *tag, int id, ns1__OrderExecuteFaultReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OrderExecuteFaultReq);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__OrderExecuteFaultReq ** SOAP_FMAC4 soap_in_PointerTons1__OrderExecuteFaultReq(struct soap *soap, const char *tag, ns1__OrderExecuteFaultReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OrderExecuteFaultReq **)soap_malloc(soap, sizeof(ns1__OrderExecuteFaultReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OrderExecuteFaultReq *)soap_instantiate_ns1__OrderExecuteFaultReq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__OrderExecuteFaultReq ** p = (ns1__OrderExecuteFaultReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OrderExecuteFaultReq, sizeof(ns1__OrderExecuteFaultReq), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OrderExecuteFaultReq(struct soap *soap, ns1__OrderExecuteFaultReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__OrderExecuteFaultReq);
	if (soap_out_PointerTons1__OrderExecuteFaultReq(soap, tag?tag:"ns1:OrderExecuteFaultReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OrderExecuteFaultReq ** SOAP_FMAC4 soap_get_PointerTons1__OrderExecuteFaultReq(struct soap *soap, ns1__OrderExecuteFaultReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OrderExecuteFaultReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OrderExecuteResultResp(struct soap *soap, ns1__OrderExecuteResultResp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OrderExecuteResultResp))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OrderExecuteResultResp(struct soap *soap, const char *tag, int id, ns1__OrderExecuteResultResp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OrderExecuteResultResp);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__OrderExecuteResultResp ** SOAP_FMAC4 soap_in_PointerTons1__OrderExecuteResultResp(struct soap *soap, const char *tag, ns1__OrderExecuteResultResp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OrderExecuteResultResp **)soap_malloc(soap, sizeof(ns1__OrderExecuteResultResp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OrderExecuteResultResp *)soap_instantiate_ns1__OrderExecuteResultResp(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__OrderExecuteResultResp ** p = (ns1__OrderExecuteResultResp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OrderExecuteResultResp, sizeof(ns1__OrderExecuteResultResp), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OrderExecuteResultResp(struct soap *soap, ns1__OrderExecuteResultResp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__OrderExecuteResultResp);
	if (soap_out_PointerTons1__OrderExecuteResultResp(soap, tag?tag:"ns1:OrderExecuteResultResp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OrderExecuteResultResp ** SOAP_FMAC4 soap_get_PointerTons1__OrderExecuteResultResp(struct soap *soap, ns1__OrderExecuteResultResp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OrderExecuteResultResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OrderExecuteResultReq(struct soap *soap, ns1__OrderExecuteResultReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OrderExecuteResultReq))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OrderExecuteResultReq(struct soap *soap, const char *tag, int id, ns1__OrderExecuteResultReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OrderExecuteResultReq);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__OrderExecuteResultReq ** SOAP_FMAC4 soap_in_PointerTons1__OrderExecuteResultReq(struct soap *soap, const char *tag, ns1__OrderExecuteResultReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OrderExecuteResultReq **)soap_malloc(soap, sizeof(ns1__OrderExecuteResultReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OrderExecuteResultReq *)soap_instantiate_ns1__OrderExecuteResultReq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__OrderExecuteResultReq ** p = (ns1__OrderExecuteResultReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OrderExecuteResultReq, sizeof(ns1__OrderExecuteResultReq), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OrderExecuteResultReq(struct soap *soap, ns1__OrderExecuteResultReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__OrderExecuteResultReq);
	if (soap_out_PointerTons1__OrderExecuteResultReq(soap, tag?tag:"ns1:OrderExecuteResultReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OrderExecuteResultReq ** SOAP_FMAC4 soap_get_PointerTons1__OrderExecuteResultReq(struct soap *soap, ns1__OrderExecuteResultReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OrderExecuteResultReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OrderCommitResp(struct soap *soap, ns1__OrderCommitResp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OrderCommitResp))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OrderCommitResp(struct soap *soap, const char *tag, int id, ns1__OrderCommitResp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OrderCommitResp);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__OrderCommitResp ** SOAP_FMAC4 soap_in_PointerTons1__OrderCommitResp(struct soap *soap, const char *tag, ns1__OrderCommitResp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OrderCommitResp **)soap_malloc(soap, sizeof(ns1__OrderCommitResp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OrderCommitResp *)soap_instantiate_ns1__OrderCommitResp(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__OrderCommitResp ** p = (ns1__OrderCommitResp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OrderCommitResp, sizeof(ns1__OrderCommitResp), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OrderCommitResp(struct soap *soap, ns1__OrderCommitResp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__OrderCommitResp);
	if (soap_out_PointerTons1__OrderCommitResp(soap, tag?tag:"ns1:OrderCommitResp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OrderCommitResp ** SOAP_FMAC4 soap_get_PointerTons1__OrderCommitResp(struct soap *soap, ns1__OrderCommitResp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OrderCommitResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OrderCommitReq(struct soap *soap, ns1__OrderCommitReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OrderCommitReq))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OrderCommitReq(struct soap *soap, const char *tag, int id, ns1__OrderCommitReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OrderCommitReq);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__OrderCommitReq ** SOAP_FMAC4 soap_in_PointerTons1__OrderCommitReq(struct soap *soap, const char *tag, ns1__OrderCommitReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OrderCommitReq **)soap_malloc(soap, sizeof(ns1__OrderCommitReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OrderCommitReq *)soap_instantiate_ns1__OrderCommitReq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__OrderCommitReq ** p = (ns1__OrderCommitReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OrderCommitReq, sizeof(ns1__OrderCommitReq), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OrderCommitReq(struct soap *soap, ns1__OrderCommitReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__OrderCommitReq);
	if (soap_out_PointerTons1__OrderCommitReq(soap, tag?tag:"ns1:OrderCommitReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OrderCommitReq ** SOAP_FMAC4 soap_get_PointerTons1__OrderCommitReq(struct soap *soap, ns1__OrderCommitReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OrderCommitReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
